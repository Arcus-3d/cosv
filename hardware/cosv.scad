//COSV - Cam Open Source Ventilator
// Project home: https://hackaday.io/project/170507
// Project files: https://github.com/Arcus-3d/cosv
// Project authors: Daren Schwenke, Steven Carr
// Project license: <This really needs to get absolutely nailed down. 
//                   Here. 
//                   *Now*  
//                   Feel free to fix this problem by modifying this structure and committing the resulting files with a *very* specific OSHW license for computationally generated hardware design files.
//                   Welcome to my everlasting grey area of which I do not know how to get out of, but I am desperately trying to avoid.>
//                   *end of line*
//


/* [Global] */

/* [COSV Customization] */
// Circle complexity: Turn down to about 30 for working, up to like 90 for rendering
param_complexity=90; // [1:100]

// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this. Smaller values result in smoother, but more complicated surfaces.  A good value for working is 15. A good value for rendering is 2-5.
param_path_step=15; // [1:15]

// Line width for laser cutting.  Affects hole sizes
param_kerf=0.15; // [0.000:0.005:0.500]

// Motor mount selection
param_motor="wiper"; // [wiper:Ford F150 Wiper Motor,bldc:BLDC Brushless Motor,worm:Worm gear motor,nema23:Nema23 Stepper with 6mm shaft,nema23-635:Nema23 Stepper with 6.35mm shaft]

// Is the motor shaft D-Shaped?
param_d_shaft = "auto"; // [zero:Circular,one:D-Shaped,two:Double-D shaped (wiper motor),auto:D or DD based on motor type]

// Which one would you like to see?
param_part = ""; // [cam:cam top/bottom - need 2,paddle:paddle for the arms - need 2,base_mount_bottom:base plate/motor mount - need 1,base_mount_top:top plate/electronics mount - need 1,bldc_motor_standoff:bldc motor standoff - need 1,bag_mount:Thin arms to support the bag ends and keep it from wandering - need 2,arm:Arm,supply_cover:Power Supply cover,chest_bar:Chest bar,flow_sensor_for_pcb:Flow sensor body for use with a PCB (pitot style),flow_sensor_venturi_for_pcb:Flow sensor body for use with a PCB (venturi style),flow_sensor_for_pcb_no_pocket:Flow sensor test body,flow_sensor_cover_oled:Flow sensor cover for use with embedded OLED,flow_sensor_cover:Flow sensor cover,flow_sensor_test:Test apparatus for the flow sensor,bearing_bushing:bearing_busing - used within the other FFF parts,bearing_washer:bearing_washer - used within the other FFF parts,laser_callibration_square_10x10mm:Laser calibration square - A 10x10mm square in case units don't go over with the svg export,laser_arm_mount:Laser arm mount - raised area by arm bearings as a layer,laser_bearing_washer:  washer - if laser cutting it,laser_cam:Laser cam top/bottom - need 2,laser_cam_center:Laser cam center - Stronger - but you need to glue it to top/bottom,laser_bearing_bushing:Laser bearing bushing to make up the difference between bolt_r and bearing_ir - need 2,laser_bldc_motor_standoff:Laser bldc motor has an input shaft that sticks out too far,laser_base_mount_top:Laser base - top plate,laser_base_mount_bottom:Laser base - bottom plate,laser_paddle:Laser paddle for arm ends - need 2,laser_arm:Laser arms - need 2,laser_bag_mount:Laset bag mounting arm - need 2]


/* [Hidden] */


// Laser parts
param_partl="";



// Don't touch $fn, the param_complexity variable is over-ridden in the makefile
$fn=param_complexity;


// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface
// while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this.
// Smaller values result in smoother, but more complicated surfaces.  
// A good value for working is 15. A good value for rendering is 2-5.
path_step=param_path_step; // [115]


// Assembly views, a little broken.
//rotate([90,0,0]) cosv_assembly_view(cam_angle=$t*180,explode=20);
//cam_assembly_view(explode=10);
//flow_sensor_assembly_view(rot=360*$t,explode=0.1);

// The parts.
// Uncomment these to generate them, render, export.
// for the laser files, export as svg.





PART=param_part;

if (PART == "cam") {
	cam(); // cam top/bottom.  Need 2.
} else if (PART == "paddle") {
	paddle(); // paddle for the arms.  Need 2
} else if (PART == "base_mount_bottom") {
	base_mount_bottom(); // base plate/motor mount.  Adjust the bolt pattern you need below first.  Need 1.
} else if (PART == "base_mount_top") {
	base_mount_top(); // top plate/electronics mount.  Need 1.
} else if (PART == "bldc_motor_standoff") {
	bldc_motor_standoff(); // bldc motor has a long pilot on it, which requires a standoff. Need 1.
} else if (PART == "bag_mount") {
	bag_mount(); // thin arms to support the bag ends and keep it from wandering. Need 2.
} else if (PART == "arm") {
	arm();
} else if (PART == "supply_cover") {
	supply_cover();
} else if (PART == "flow_sensor_for_pcb") {
	flow_sensor_for_pcb();
} else if (PART == "flow_sensor_venturi_for_pcb") {
	flow_sensor_venturi_for_pcb();
} else if (PART == "flow_sensor_for_pcb_no_pocket") {
	flow_sensor_for_pcb_no_pocket();
} else if (PART == "flow_sensor_cover_oled") {
	flow_sensor_cover(oled=0);
} else if (PART == "flow_sensor_cover") {
	flow_sensor_cover();
} else if (PART == "flow_sensor_test") {
	flow_sensor_test();
} else if (PART == "bearing_bushing") {
	bearing_bushing(); // parts used within the other FFF parts
} else if (PART == "bearing_washer") {
	bearing_washer(); // parts used within the other FFF parts

// Laser parts.  Arms at least should have arm_w (below) turned up as acrylic isn't as strong as FFF.

} else if (PART == "laser_callibration_square_10x10mm") {
	laser_callibration_square(w=10); // A square, 10x10mm in case units don't go over with the svg export.
} else if (PART == "laser_arm_mount") {
	laser_arm_mount(); // raised area by arm bearings as a layer
} else if (PART == "laser_bearing_washer") {
	laser_bearing_washer(); // washer, if laser cutting it
} else if (PART == "laser_cam") {
	laser_cam(); // cam top/bottom
} else if (PART == "laser_cam_center") {
	laser_cam_center(); //cam center.  Stronger, but you need to glue it to top/bottom
} else if (PART == "laser_bearing_bushing") {
	laser_bearing_bushing(); // bushing to make up the difference between bolt_r and bearing_ir
} else if (PART == "laser_bldc_motor_standoff") {
	laser_bldc_motor_standoff(); // bldc motor has an input shaft that sticks out too far
} else if (PART == "laser_base_mount_top") {
	laser_base_mount_top(); // base, top plate
} else if (PART == "laser_base_mount_botom") {
	laser_base_mount_bottom(); // base, top plate
} else if (PART == "laser_base_end_bottom") {
	laser_base_end_bottom(); // base, top plate
} else if (PART == "laser_base_end_top") {
	laser_base_end_top(); // base, top plate
} else if (PART == "laser_base_mount_bottom") {
} else if (PART == "laser_paddle") {
	laser_paddle(); // paddle for arm ends
} else if (PART == "laser_arm") {
	laser_arm(); // The arms (when symetrical).
} else if (PART == "laser_arm_end_support") {
	laser_arm_end_support(); // The arm end.
} else if (PART == "laser_bag_mount") {
	laser_bag_mount();
}
//laser_base_mount_top(); // base, top plate
//laser_base_mount_bottom(); // base, top plate
//laser_arm(path_step=1,$fn=90); // base, top plate
//laser_arm_end_support(path_step=1,$fn=90); // extend the normal arm end +z for a stacked solution to flex
//laser_arm_mount(); // base, top plate
//laser_base_end_bottom(); // base, top plate
//laser_base_end_top(); // base, top plate
//laser_base_front(); // base front
//laser_base_back(); // base back
//laser_cam_end_plate_t(); // base back
//laser_cam_end_plate_b(); // base back
//laser_cam_center_b(); // base back
//laser_cam_center_t(); // base back
//laser_bearing_bushing(r=6/2); // parts used within the other FFF parts

//cam(); // cam top/bottom.  Need 2.
paddle(); // paddle for the arms.  Need 2
//base_mount_bottom(); // base plate/motor mount.  Adjust the bolt pattern you need below first.  Need 1.
//base_mount_top(); // base plate opposite motor mount. Need 1.
//base_end_top(); // base end plate/bag mounts.  Need 1, top bag end diameter.
//base_plate(); // top plate/electronics mount.  Need 1.
//bldc_motor_standoff(); // bldc motor has a long pilot on it, which requires a standoff. Need 1.
//arm();
//supply_cover();
//flow_sensor_for_pcb();
//flow_sensor_venturi_for_pcb();
//flow_sensor_for_pcb_no_pocket();
//flow_sensor_cover(oled=0);
//flow_sensor_cover();
//flow_sensor_test();
//bearing_bushing(); // parts used within the other FFF parts
//bearing_washer(); // parts used within the other FFF parts
//laser_base_mount_top(); // base, bottom plate
//laser_base_mount_bottom(); // base, bottom plate


// Abbreviations
// r=radius (and sometimes rotation within modules)
// ir=inner radius
// or=outer radius
// t=thickness
// l=length
// h=height
// x,y,z = dimensions in x,y,z

// Clearance for parts, and extra length to make subtractions clean.
clearance=0.4;
extra=0.02;

// nozzle size for 3D printing.  Generates parts that are exactly a multiple of this width for strength
nozzle_r=0.4/2;

// line width for laser cutting.  Affects hole sizes (param_kerf is CLI overridden by Makefile)
kerf=param_kerf;
// material thickness for laser cutting
material_t=3.0;


arm_w=12*nozzle_r*2; // bearing choice.  Some things don't scale right yet if you change this.
arm_h=material_t*3;
bearing_or=22/2-kerf;
bearing_ir=8/2+kerf;
bearing_h=7;
// battery dimensions

battery_x=150;
battery_z=65;
battery_y=100;
battery_y_offset=0;
battery_z_offset=0;

// bag dimensions and position
bvm_r=125/2;
bvm_br=62/2;
bvm_tr=41/2;
bvm_l=200;
bvm_c=nozzle_r*2*8; // Thickness for bag parts
bvm_y_offset=30; // Moves the bag location up/down
bvm_y_center=bvm_r+bearing_or/2+bvm_y_offset+arm_w*2;
tft_h=50+clearance;
tft_w=86+clearance;
tft_d=6;
tft_y_offset=tft_h/5;
tft_screen_h=50; // the whole glass poking through
tft_screen_w=70;
//tft_screen_h=45; // just the active part
//tft_screen_w=59;
//tft_d=8;

// a little washer to clearance the bearing
bearing_washer_h=(arm_h-bearing_h)/2;

// assembly bolt size
cam_bolt_r=4/2+clearance/4-kerf;
arm_bolt_r=8/2+clearance/4-kerf;
cover_bolt_r=3/2+clearance/4-kerf;
wire_t=1.25;

// compression rotation angle.  You can generate uneven compression/release profiles with this for a weaker motor, or to have hardware ratio of inhale/exhale and a static motor.
comp_rot=90;

// arm width (If it is laser, do one thing, else FFF, do another

// paddle internal ribs and top thickness
paddle_scale=1.5;
paddle_t=3*nozzle_r*2;
paddle_rib_w=3*nozzle_r*2;

// how far the arm rotates with a full comp_rot
arm_rot=30; 
// how far apart the arm bearings are from centerline
arm_x_offset=22;

// mechanical dimensions for the cam action
cam_bearing_offset=22;
cam_l=cam_bearing_offset*2+bearing_or*2;
cam_h=material_t*7;
cam_y_offset=bearing_or+cam_l/2+arm_w;
cam_pre_rot=-0;
x_pos=bvm_r+bvm_c*6;
housing_h=cam_l+cam_y_offset;
y_pos=bvm_y_center-bvm_r-bvm_c*4-housing_h/2;
front_recess=arm_w*2;
supply_cover_x=38;
supply_cover_y=98;
supply_cover_z=20;
supply_cover_t=1.6;

// volume sensing pitot tube dimensions
// outer tube.  This is the dia of the mask, generally
tube_or=22/2;
tube_taper=nozzle_r;
tube_ir=tube_or-nozzle_r*2*6;
// depth of the socket/tube
tube_d=19;

pcb_t=1.6+3.2+clearance; // Board is 1.6, OLED is 5.2mm tall.  Recess in lid is 2mm.
pcb_c_t=2.4;
pcb_b=1.6;
pcb_x=21+clearance;
pcb_y=47+clearance;
pcb_z_offset=4;
pcb_port_z_offset=8;
pcb_port_z_spacing=4;
pcb_port_x_spacing=4;
pcb_bolt_spacing=24;
pcb_cover_t=2.8;
pcb_cable_t=1.5;

// total length
tube_l=tube_d*2+(pcb_y-tube_d)+pcb_z_offset+tube_d*1.25;
vent_l=tube_l/1.35;
vent_h=vent_l/8;
vent_r=8/2;

// inner pitot tube
pitot_r=6/2;
pitot_t=nozzle_r*2*3;
port_r=5.25/2;
pitot_snap_offset=.05;
// oled
oled_x=12+clearance;
oled_y=39+clearance;
oled_pin_h=1;
oled_t=2+oled_pin_h;
oled_glass_x=9;
oled_glass_x_offset=-1;
oled_glass_y=26;

// param_motor is defined at the top of the file (and over-ridden by CLI in Makefile)
MOTOR=param_motor;

// Support makefile passing this in, we have rendered each motor have D or !D shaped for the cams
d_shaft = (param_d_shaft=="zero" ? 0 : 
          (param_d_shaft=="one" ? 1 :
	  (param_d_shaft=="two" ? 2 :
	  (param_d_shaft=="auto" ? (MOTOR=="wiper" ? 2 : (MOTOR=="worm" ? 1 : (MOTOR=="nema23" ? 1 : 0))) : 0))));
motor_tri = (MOTOR=="wiper" ? 1 : 0);
motor_tri_angle = (MOTOR=="wiper" ? 53 : 60);
motor_mount_offset = (MOTOR=="wiper" ? 0
                   : (MOTOR=="worm" ? 9
                   : (MOTOR=="nema23" ? 47.1/2
                   : (MOTOR=="nema23-635" ? 47.1/2
                   : (MOTOR=="bldc" ? 6.25 : 0)))));
motor_mount_x = (MOTOR=="wiper" ? -35
              : (MOTOR=="worm" ? 18
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 15.5 : 0)))));
motor_mount_y = (MOTOR=="wiper" ? -46
              : (MOTOR=="worm" ? 33
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 26.75 : 0)))));
motor_r = (MOTOR=="wiper" ? 54
        : (MOTOR=="bldc" ? 37/2 : 0));
motor_bolt_r = (MOTOR=="wiper" ? 6/2+clearance/4-kerf
             : (MOTOR=="worm" ? 3/2+clearance/4-kerf
             : (MOTOR=="nema23" ? 4/2+clearance/4-kerf
             : (MOTOR=="nema23-635" ? 4/2+clearance/4-kerf
             : (MOTOR=="bldc" ? 3/2+clearance/4-kerf : 0))))); 
motor_pilot_r = (MOTOR=="wiper" ? 24/2+clearance-kerf
              : (MOTOR == "worm" ? 6/2+clearance-kerf
              : (MOTOR == "nema23" ? 38.1/2+clearance-kerf
              : (MOTOR == "nema23-635" ? 38.1/2+clearance-kerf : 0))));
motor_shaft_r = (MOTOR=="wiper" ? 12/2+clearance/4-kerf
              : (MOTOR == "worm" ? 6/2-kerf
              : (MOTOR == "nema23" ? 8/2-kerf
              : (MOTOR == "nema23-635" ? 6.35/2-kerf
              : (MOTOR=="bldc" ? 6/2-kerf : 0)))));
motor_shaft_flat_x = (MOTOR=="wiper" ? 8.1/2 : 0);
motor_shaft_flat_y = (MOTOR=="wiper" ? 11/2 : 0);
motor_body_y_offset = (MOTOR=="bldc" ? -7 : 0);


module laser_bag_mount() {
	projection(cut=true) bag_mount(t=arm_w*1.5);
}
module laser_base_mount_top() {
	projection(cut=false) base_mount_top();
}
module laser_base_mount_bottom() {
	projection(cut=false) base_mount_bottom();
}
module laser_bearing_washer() {
	projection(cut=true) bearing_washer();
}
module laser_cam_end_plate_b() {
	projection(cut=true) cam_end_plate();
}
module laser_cam_end_plate_t() {
	projection(cut=true) cam_end_plate(motor_shaft_r=6/2,d_shaft=0);
}
module laser_cam_center_b() {
	projection(cut=true) cam_center();
}
module laser_cam_center_t() {
	projection(cut=true) cam_center(motor_shaft_r=6/2,d_shaft=0);
}
module laser_arm_mount() {
	projection(cut=true) difference() {
		arm_mount();
		translate([0,0,-material_t*2]) motor_holes();
	}
}
module laser_arm($fm=90,path_step=1) {
	//arm_model();
	projection(cut=true) arm_model($fn=$fn,path_step=path_step);
}
module laser_arm_end_support($fm=90,path_step=1) {
	projection(cut=true) arm_end_support($fn=$fn,path_step=path_step);
}
module laser_paddle() {
	
	projection(cut=true) paddle(laser=1,h=arm_w);
}
module laser_bearing_bushing(r=cam_bolt_r) {
	projection(cut=true) bearing_bushing(r=r);
}
module laser_base_end_bottom() {
	projection(cut=false) base_end_bottom();
}
module laser_base_bottom() {
	projection(cut=true) base_bottom();
}
module laser_base_top() {
	projection(cut=true) base_top();
}
module laser_base_front() {
	projection(cut=true) base_front();
}
module laser_base_back() {
	projection(cut=true) base_back();
}

module laser_base_end_top() {
	projection(cut=false) base_end_top();
}
module laser_base_mount_bottom() {
	projection(cut=false) base_mount_bottom();
}
module laser_callibration_square(w=10) {
	projection(cut=true) cube([w,w,w],center=true);
}
module laser_bldc_motor_standoff() {
	projection(cut=true) bldc_motor_standoff();
}

// now a little screwed up since I split the parts into layers
module cosv_assembly_view(explode=0,cam_angle=0) {
	if (1) translate([0,bvm_y_center,0]) {
	//if (0) {
		//$fn=32;
		if (cam_angle < comp_rot) {
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		} else { 
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		}
	}
	if (0) translate([0,bvm_y_center+bvm_r*1.15,0]) cylinder(r=arm_bolt_r*2,h=bvm_l,center=true);
	if (0) translate([0,bvm_y_center+bvm_r*1.15,0]) #cylinder(r=arm_bolt_r,h=bvm_l+bvm_c*3,center=true);
	if (0) translate([0,0,-bvm_l/2-explode*3]) base_end_bottom();
	if (0) translate([0,0,-cam_h/2-material_t*3-clearance*2]) base_mount_bottom();
	if (1) translate([0,y_pos-housing_h/2-bvm_c*3+material_t/2-explode,0]) rotate([90,0,0]) base_bottom();
	if (1) translate([0,y_pos+housing_h/2+bvm_c*3+material_t/2+explode/4,0]) rotate([90,0,0]) base_top();
	if (0) translate([x_pos+bvm_c*3-material_t/2-front_recess+explode,y_pos,0]) rotate([90,0,90]) base_front();
	if (1) translate([-x_pos-bvm_c*3+material_t/2+front_recess-explode,y_pos,0]) rotate([90,0,270]) base_back();
	if (1) translate([0,0,cam_h/2+material_t*3+clearance*2]) rotate([0,180,0]) mirror([1,0,0]) base_mount_top();
	if (1) translate([0,0,bvm_l/2+explode*3]) rotate([0,180,0]) base_end_top();
	if (0) translate([0,y_pos,bvm_l/2-material_t-battery_z/2]) #cube([battery_x,battery_y,battery_z],center=true);
	if (1) translate([0,-cam_y_offset,0]) rotate([0,0,-cam_angle+cam_pre_rot]) cam_assembly_view(explode=0);
	if (1) translate([0,0,-bvm_l/2-bvm_c*3/2]) #base_corners(x_pos=x_pos-front_recess,r=arm_bolt_r,h=bvm_l+bvm_c*3);
	if (1) translate([arm_x_offset,0,-material_t]) {
		translate([0,0,bearing_h/2+extra/2]) bearing();
		if (cam_angle < comp_rot) {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,cam_angle/(comp_rot/arm_rot)]) {
				arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w/2,bvm_y_center,material_t*3/2]) rotate([0,-90,0]) translate([0,bvm_c,-bvm_c*2.5]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		} else {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-cam_angle/(comp_rot/arm_rot)]) {
				%arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w/2,bvm_y_center,material_t*3/2]) rotate([0,-90,0]) translate([0,bvm_c,-bvm_c*2.5]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		}
	}
	if (1) translate([-arm_x_offset,0,-material_t]) {
		translate([0,0,bearing_h/2+extra/2]) bearing();
		if (cam_angle < comp_rot) {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,-cam_angle/(comp_rot/arm_rot)]) {
				%arm();
				if (1) translate([arm_x_offset-bvm_r-arm_w/2,bvm_y_center,material_t*3/2]) rotate([0,90,0]) translate([0,bvm_c,-bvm_c*2.5]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		} else {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,-comp_rot/(comp_rot/arm_rot)*2+cam_angle/(comp_rot/arm_rot)]) {
				%arm();
				if (1) translate([arm_x_offset-bvm_r-arm_w/2,bvm_y_center,material_t*3/2]) rotate([0,90,0]) translate([0,bvm_c,-bvm_c*2.5]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		}
	}
}


module flow_sensor_assembly_view(explode=0,rot=0) {
	vent_t=tube_or-tube_ir;
	rotate([0,0,rot]) {
		flow_sensor_venturi_for_pcb();
		translate ([0,vent_t+explode,0]) flow_sensor_cover_model(oled=1);
	}
}

module cam_assembly_view(explode=0) {
	translate([0,0,-explode*2-material_t*7/2]) cam(explode=explode);
	for(i=[-1,1]) translate([0,cam_bearing_offset*i,0]) bearing();
	translate([0,0,explode*2+material_t*7/2]) rotate([0,180,0]) cam(explode=explode);
	translate([0,0,explode*3+material_t*16/2]) cam_encoder();
}
module flow_sensor_cover(oled=0) {
	t=tube_or-tube_ir;
	translate([0,-tube_l/2-tube_d/1.5,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t/2+pcb_b]) rotate([-90,0,0]) flow_sensor_cover_model(oled=oled);
}

module supply_cover() {
	difference() {
		union() {
			translate([0,0,supply_cover_z/2]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z],center=true);
			translate([0,arm_bolt_r+supply_cover_t+clearance/2,supply_cover_z/4]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z/2],center=true);
			hull() {
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r*2,h=supply_cover_x+supply_cover_t*2,center=true);
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r/2,extra/2]) cube([supply_cover_x+supply_cover_t*2,extra,extra],center=true);
			}
			
		}
		translate([0,0,supply_cover_z+supply_cover_t]) cube([supply_cover_x,supply_cover_y,supply_cover_z*2],center=true);
		translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r+clearance/2,h=supply_cover_x+supply_cover_t*2+extra,center=true);
		for (y=[-1,1]) translate([0,supply_cover_y*0.25*y,supply_cover_t/2]) cylinder(r=5.4/2,h=supply_cover_t*4,center=true);
	}
}
module flow_sensor_cover_model(oled=0) {
	t=tube_or-tube_ir;
	vent_t=t;
	if (1) difference() {
		union() {
			hull() for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t+pcb_c_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) {
				rotate([90,0,0]) cylinder(r=pcb_b/2,$fn=$fn/2,h=extra,center=true);
				translate([x*-0.1,pcb_cover_t-pcb_b/2,0]) sphere(r=pcb_b/2,$fn=$fn/2,center=true);
			}
			translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2+wire_t,tube_l-pcb_b*5/2]) difference() {
				translate([0,-pcb_t/2,0]) cube([pcb_x/3-clearance,pcb_c_t+pcb_cover_t,pcb_b*5+extra],center=true);
				translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
				translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
			}
			// oled rim
			translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset-pcb_b*1.5]) cube([pcb_x-clearance,oled_t/2+extra,oled_y+pcb_b*4],center=true);
			// cover mount
			translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t-pcb_cover_t*0.85,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
				cube([pcb_x-clearance,extra,pcb_b*2.5-clearance/2],center=true);
				rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2-clearance/2,h=pcb_x-clearance,center=true);
			}
		}
		// oled pocket
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b+extra,oled_y+clearance],center=true);
		// oled pins
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2+oled_pin_h,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset+oled_y/2-pcb_b]) cube([oled_x+clearance,oled_t+pcb_b/2+extra,oled_t+pcb_b*2],center=true);
		// oled display opening
		if (oled) translate([oled_glass_x_offset,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset]) hull() {
			cube([oled_glass_x+t*2,extra,oled_glass_y+t*2],center=true);
			translate([0,-t,0]) cube([oled_glass_x,extra,oled_glass_y],center=true);
		}
		// screw holes
		// cover screw holes
		for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
			rotate([90,0,0]) cylinder(r=cover_bolt_r+clearance/4,h=pcb_t+pcb_c_t+t,center=true);
			translate([0,pcb_cover_t*2,0]) rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
		}
		//translate([0,tube_or+t+pcb_t+pcb_c_t+oled_t/2-pcb_b,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b*2+extra,oled_y+clearance],center=true);
	}
}

// holes still don't scale for depth correctly.
module flow_sensor_for_pcb_no_pocket() {
	t=tube_or-tube_ir;
	intersection() {
		translate([0,0,0]) cube([1000,tube_or*2+t*2+pcb_t*0.91,1000],center=true);
		flow_sensor_for_pcb();
	}
}

module flow_sensor_venturi_for_pcb(sla=1) {
	t=tube_or-tube_ir;
	vent_t=t;
	difference() {
		if (1) union() { // Change to 0 to see all the cutouts
			// body bottom
			for (r=[0,90,180,270]) rotate([0,0,r]) hull() {
				translate([0,tube_or-tube_or/2,tube_d*1.05]) cylinder(r=tube_or/2+tube_taper,h=extra,center=true);
				translate([0,tube_or-tube_or/2,extra]) cylinder(r=tube_or/2,h=extra,center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// body top 
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t/2+pcb_c_t/2+vent_t,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
				translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) sphere(r=port_r/2+nozzle_r*20,center=true);
			}
		}
		difference() {
			if (1) union() {
				// cover screw holes
				for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=pcb_t+pcb_c_t+t+cover_bolt_r*2,center=true);
					translate([0,pcb_cover_t*2,0]) {
						rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
						hull() {
							translate([0,-cover_bolt_r*8.5,0]) sphere(r=cover_bolt_r-clearance/4,center=true);
							translate([0,-cover_bolt_r*6,-cover_bolt_r*6]) sphere(r=cover_bolt_r-clearance/4,center=true);
						}
					}
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2+vent_t,tube_l-pcb_b*3-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t-nozzle_r*4+extra*2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(nozzle_r*4) {
						translate([0,pcb_t*1.15]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,-pcb_t*0.15,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=tube_or*2+t*2+extra,center=true);
				}
				// venturi
				translate([0,0,t/8]) cylinder(r2=tube_ir,r1=tube_ir+t/4,h=t/4+extra,center=true);
				translate([0,0,tube_d/2]) cylinder(r=tube_ir,h=tube_d+extra,center=true);
				translate([0,0,tube_l/2]) {
					translate([0,0,-vent_l/4-vent_h/2-vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
					translate([0,0,-vent_l/8-vent_h/2]) cylinder(r1=tube_ir,r2=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,0]) cylinder(r=vent_r,h=vent_h+extra,center=true);
					translate([0,0,vent_l/8+vent_h/2]) cylinder(r2=tube_ir,r1=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,vent_l/4+vent_h/2+vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
				}
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					rotate([0,0,45]) hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_cover_t+pcb_t+pcb_c_t,tube_l-pcb_b*5/2]) difference() {
					translate([0,-pcb_t/2,0]) cube([pcb_x/3+clearance/2,pcb_c_t+pcb_cover_t,pcb_b*20+extra],center=true);
					translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
					translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				translate([0,vent_t,0]) difference() {
					union() {
						if (1) hull() {
							translate([0,tube_or+t,tube_l-pcb_t-pcb_c_t-pcb_t-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t,tube_l-(pcb_y+pcb_b*5.5-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-vent_t-pcb_b*3+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
						}
						if (1) hull() {
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-pcb_y-pcb_z_offset-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t+pcb_c_t,tube_l-pcb_y+pcb_z_offset]) cube([pcb_x,extra,pcb_port_z_offset*2+pcb_b*2],center=true);
						}
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=t*5,center=true);
					hull() {
						translate([0,-t*5/2,0]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
						translate([0,-t*7.8/2,-t/2]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
					}
				}
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*1.5;
				// ports
				translate([0,vent_t,0]) {
					if (1) for (x=[-1,1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t*4,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,-port_r/8]) sphere(r=port_r,center=true);
					}
					for (x=[-1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t*4,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,-port_r/8]) sphere(r=port_r,center=true);
					}
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) sphere(r=port_r/2,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) sphere(r=port_r/2,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						translate([pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([pcb_port_x_spacing,-pcb_c_t/2+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8+port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
						translate([0,-vent_t,0]) rotate([0,0,-30]) translate([0,vent_r-t+port_r+vent_t,tube_l/2]) scale([1,1,1.75]) rotate([30,-30,0]) sphere(r=port_r/2,$fn=6,center=true);
					}
					translate([0,-vent_t,0]) {
						for (r=[-1,1]) rotate([0,0,90*r]) translate([0,vent_r-t+vent_t+port_r/2-nozzle_r,tube_l/2]) scale([1,1,1.75]) {
							rotate([90,30,0]) cylinder(r=port_r/2,$fn=6,h=port_r+nozzle_r*2,center=true);
							hull() translate([0,port_r/2+nozzle_r,0]) for (r=[0,90]) rotate([0,0,r]) rotate([0,90,0]) cylinder(r=port_r/2,h=extra,$fn=6,center=true);
						}
						intersection() {
							translate([0,tube_or,tube_l/2,]) cube([tube_or*2,tube_or*2,tube_l],center=true);
							rotate_extrude() translate([vent_r-t+vent_t+port_r,tube_l/2]) scale([1,1.75]) rotate([0,0,30]) circle(r=port_r/2,$fn=6,center=true);
						}
					}
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		#if (sla) for (r=[90]) rotate([0,0,r]) translate([tube_ir+t/2,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=t*2,center=true);
	}
}
module flow_sensor_for_pcb() {
	t=tube_or-tube_ir;
	difference() {
		if (1) union() {
			// bottom taper
			for (r=[0,90]) rotate([0,0,r]) hull() {
				translate([0,0,tube_d*1.05]) cube([tube_or*2+tube_taper*2,t,extra],center=true);
				translate([0,0,extra/2]) cube([tube_or*2-clearance/2,t,extra],center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// bottom bevel.  SLA printers didn't like this...
			//translate([0,0,t/4]) cylinder(r1=tube_or-t/4,r2=tube_or,h=t/2,center=true);
			// top
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				//translate([0,0,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset]) cylinder(r=tube_or+t,h=pcb_y+pcb_b*2+pcb_z_offset*2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(pcb_x+pcb_b)/2*x,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
// cube([pcb_x+pcb_b*2,pcb_t+pcb_c_t,pcb_y+pcb_b*2+pcb_z_offset*2],center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
			}
		}
		difference() {
			if (1) union() {
				// screw holes
				for (x=[-1,1]) for (z=[1]) translate([(pcb_x+pcb_b-t*3)/2*x,tube_or+t*2.8+pcb_cover_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2-t*2.5)/2*z]) {
					rotate([90,0,0]) cylinder(r=3/2-clearance,h=pcb_t+pcb_c_t+t,center=true);
					translate([0,pcb_cover_t,0]) rotate([90,0,0]) cylinder(r1=3/2,r1=3,h=3,center=true);
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2,tube_l-pcb_b*2-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t/2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(1) {
						translate([0,pcb_t]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=pcb_x*2,center=true);
				}
				// center cutout
				translate([0,0,tube_l/2]) cylinder(r=tube_ir,h=tube_l+extra*2,center=true);
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) difference() {
					cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset+extra],center=true);
					translate([0,-pcb_t/2-pcb_c_t/2-pcb_cover_t/2,-t/2]) rotate([0,90,0]) cylinder(r=t/3,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				difference() {
					union() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b-pcb_port_z_offset)/2]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_t/2+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([pcb_x,pcb_t+extra,pcb_y+pcb_b+extra],center=true);
					}
					difference() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-pcb_b]) rotate([-45,0,0]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset*2+extra],center=true);
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/2,h=t*3.75,center=true);
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*3;
				// ports
				for (x=[-1,1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				for (x=[-1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
			rotate([0,0,25]) { // if you alter the depth of the ports, this needs to change and I'm too lazy to do that math.
				translate([0,0,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset]) intersection() {
					union() {
						for (r=[1,0]) mirror([0,0,r]) translate([0,tube_ir,tube_ir+pcb_port_z_spacing]) rotate([0,90,0]) difference() {
							union() {
								rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r+pitot_t,center=true);
								translate([tube_ir/2+pcb_port_x_spacing/2,(-tube_or-t)/2,0]) cube([tube_ir+pcb_port_x_spacing,tube_or+t+pitot_r+pitot_t-pcb_b,pitot_t],center=true);
							}
							rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
						}
					}
					translate([0,(tube_ir+t-pitot_r-pitot_t-pcb_b)/2+clearance/4,0]) cube([tube_ir,tube_ir+t+pitot_r+pitot_t-pcb_b,(tube_ir+pcb_port_z_spacing)*2],center=true);
				}
				if (1) difference() {
					h=tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset-nozzle_r-(tube_ir+pcb_port_z_spacing);
					union() {
						translate([0,0,h/2-pitot_t/2]) cylinder(r=pitot_r+pitot_t*2,h=h-pitot_t,center=true);
						translate([0,0,h-pitot_t/2-pitot_snap_offset]) difference() {
							cylinder(r1=pitot_r+pitot_t*2,r2=pitot_r+nozzle_r*3,h=pitot_t*1.25,center=true);
							for(r=[0:45:180]) rotate([0,0,r]) cube([pitot_t,tube_or,pitot_t*1.25+extra],center=true);
						}
					}
					translate([0,0,h/2]) cylinder(r=pitot_r+nozzle_r,h=h*1.5+extra,center=true);
				
					
				}
			}
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		for (r=[0:90:365]) rotate([0,0,r]) translate([0,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=tube_or*2+t*4,center=true);
	}
}
module flow_sensor_test() {
	pitot_r=7/2;
	pitot_t=nozzle_r*2*2;
	port_r=5.25/2;
	o_offset=10;
	tube_l=tube_ir*2+o_offset*2;
	translate([0,0,tube_l/2]) difference() {
		if (1) union() {
			cylinder(r=tube_or,h=tube_l,center=true);
			rotate([90,0,0]) hull() for (z=[1,-1]) translate([0,z*o_offset,-tube_or/1.5]) cylinder(r=tube_or/2,h=tube_or/1.15,center=true);
		}
		difference() {
			cylinder(r=tube_ir,h=tube_l+extra,center=true);
			difference() {
				cube([pitot_r*2+pitot_t*2,tube_or*2,tube_l],center=true);
				for (r=[1,0]) mirror([0,0,r]) scale([1,1,1]) translate([0,tube_ir,-tube_ir-o_offset]) rotate([0,90,0]) intersection() {
					rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
				}
			}
		}
		for (r=[90,-90]) rotate([0,r,0]) intersection() {
			cube([pitot_r*2+pitot_t*2,tube_or*2,pitot_r*2+pitot_t*2+extra],center=true);
			scale([1,1,1]) translate([0,tube_ir,-tube_ir]) rotate([0,90,0]) {
				rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
			}
		}
		for (z=[-1,0,1]) translate([0,tube_ir+4,z*o_offset]) rotate([90,0,0]) translate([0,0,0]) cylinder(r=port_r,h=8*2,center=true);
		
	}
}

module bearing_bushing(h=bearing_h,r=bearing_ir-clearance/8) {
	difference() {
		translate([0,0,h/2]) cylinder(r=r,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=cam_bolt_r,h=h+extra,center=true);
	}
}

module bearing_washer(h=bearing_washer_h,ir=cam_bolt_r,or=(bearing_or+bearing_ir)/2) {
	difference() {
		translate([0,0,h/2]) cylinder(r=or,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=ir,h=h+extra,center=true);
	}
}
	
module arm_mount_plate(h=material_t) {
	difference() {
		union() {
			hull() {
				for (x=[-1,1]) translate([x*arm_x_offset,0,h/2]) cylinder(r=bearing_or+bvm_c/4,h=h,center=true);
				hull() for (x=[-1,1]) translate([x*(arm_x_offset),bvm_y_offset-material_t*1.5,h/2]) cylinder(r=bvm_c,h=h,center=true);
			}
		}
		for (x=[-1,1]) translate([x*arm_x_offset,0,0]) {
			translate([0,0,h/2]) cylinder(r=arm_bolt_r,h=h+extra,center=true);
		}
	}
}
module arm_mount(h=material_t) {
	arm_mount_plate(h=h);
}

module base_plate(h=material_t,explode=0,r=bvm_c*5.5,x_pos=x_pos) {
	hull() base_corners(h=h,r=r,x_pos=x_pos);
}

module base_end_model(r=bvm_br,h=material_t,explode=0) {
	difference() {
		hull() {
			base_plate(h=h);
			translate([0,bvm_y_center+bvm_r*1.15,h/2]) cylinder(r=bvm_r/3,h=h,center=true);
		}
		translate([0,bvm_y_center,h/2]) cylinder(r=r,h=h+extra,$fn=$fn*2,center=true);
		//translate([0,y_pos+housing_h/2,h/2]) cylinder(r=arm_bolt_r,h=h+extra,$fn=$fn*2,center=true);
		translate([0,bvm_y_center+bvm_r*1.15,h/2]) cylinder(r=arm_bolt_r,h=h,center=true);
		base_corners(h=h,extra=extra,x_pos=x_pos-front_recess);
		
		translate([0,bvm_y_center-bvm_r/1.25,h/2]) {
			for (x=[-1,1]) translate([x*bvm_c*1.5,bvm_c*3,0]) cylinder(r=arm_bolt_r/2,h=h+extra,center=true);
			cylinder(r=arm_bolt_r*1.25,h=h+extra,center=true);
		}
		base_end_pin_slots(h=h,x_pos=x_pos-front_recess);
	}
}

module base_end_top(r=bvm_tr,h=material_t,explode=0) {
	base_end_model(r=r,h=h,explode=explode);
}

module base_end_bottom(r=bvm_br,h=material_t,explode=0) {
	base_end_model(r=r,h=h,explode=explode);
}

module base_mount_model(h=material_t*2,explode=0) {
	difference() {
		union() {
			translate([0,0,0]) base_plate(h=material_t*2,r=bvm_c*3-material_t/2,x_pos=x_pos-front_recess);
			base_end_pin_slots(h=h,x_pos=x_pos-front_recess);
			translate([0,0,h+explode]) arm_mount(h=material_t*3);
			for (x=[-1,1]) translate([arm_x_offset*x,0,0]) {
				translate([0,0,material_t*5+explode*2]) bearing_washer();
			}
			for (x=[-1]) for (y=[-0.75,0,0.75]) translate([x*(x_pos+bvm_c*3-front_recess-extra*2),y_pos+y*housing_h/2,h/2]) difference() {
				hull() {
					cube([material_t+extra*4,material_t*5,h],center=true);
					translate([-material_t*5/2,0,0]) cylinder(r=material_t*5/2,h=h,center=true);
				}
				translate([-material_t*5/2,0,0]) cylinder(r=material_t*3/2,h=h+extra,center=true);
			}
		}
		base_corners(h=h+extra,extra=extra,r=arm_bolt_r,x_pos=x_pos-front_recess);
		//base_wire_holes(h=h+extra,extra=extra);
		base_hall_holes(h=h+extra,extra=extra);
		arm_holes(h=h+extra,extra=extra);
		motor_shaft_hole(r=bearing_or,h=h+extra,extra=extra);
		translate([x_pos-(tft_d-material_t)/2,y_pos+tft_y_offset,h/2]) cube([tft_d+material_t,tft_h,h+extra],center=true);
		translate([x_pos,y_pos,h/2]) cube([material_t+extra,housing_h,h+extra],center=true);
		for (a=[-1,1]) hull() for (x=[0,1]) for (y=[-1,1]) translate([-x_pos+x*bvm_c*5,y_pos+housing_h/5.5*a+y*bvm_c*2,h/2]) cylinder(r=6/2,h=h+extra,center=true);
		hull() for (x=[0,1]) for (y=[-1,0]) translate([x_pos-(17*2-material_t)/2+x*17,-cam_y_offset+y*23,h/2]) cylinder(r=6/2,h=h+extra,center=true);
		hull() for (x=[0,1]) for (y=[1,0]) translate([x_pos-(17*2-material_t)/2+x*17,y_pos+housing_h/2-bvm_c*4.5+y*5,h/2]) cylinder(r=6/2,h=h+extra,center=true);
	}
}
module motor_shaft_hole(r=motor_shaft_r*2,h=material_t,extra=extra) {
	translate([0,-cam_y_offset,h/2]) cylinder(r=r,h=h+extra,center=true);
}
module base_mount_top(h=material_t*2,explode=0) {
	difference() {
		base_mount_model(h=h,explode=explode);
		hull() for (x=[-1,1]) for (y=[-1,0]) translate([x_pos-(17*2-material_t)/2+x*32,-cam_y_offset,h/2]) cylinder(r=6/2,h=h+extra,center=true);
	}
}

module base_mount_bottom(h=material_t*2) {
	difference() {
		base_mount_model(h=h);
		motor_holes(h=h+extra);
	}
}
module base_bottom(h=material_t) {
	difference() {
		union() {
			hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(x_pos+bvm_c*4),y*(bvm_l/2-h),h/2]) cylinder(r=extra,h=h,center=true);
			for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(x_pos-front_recess),y*(bvm_l/2-h/2),h/2]) cube([material_t*5,material_t,h],center=true);
		}
		for (x=[-1,1]) for (y=[-0.75,-0.75/2,0,0.75/2,0.75]) translate([x*(x_pos+bvm_c*3-front_recess),y*(bvm_l/2),h/2]) cube([material_t,material_t*5,h+extra*4],center=true);
		for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(x_pos-front_recess),y*(material_t*5.5+clearance*2),h/2]) cube([material_t*5,material_t*2,h+extra*4],center=true);
	}
}
module base_front_model(h=material_t) {
	difference() {
		union() {
			hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(housing_h/2+bvm_c*3-material_t/2),y*(bvm_l/2-h),h/2]) cylinder(r=extra,h=h,center=true);
			for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(housing_h/2),y*(bvm_l/2-h/2),h/2]) cube([material_t*5,material_t,h],center=true);
			for (x=[-1,1]) for (y=[-0.75,-0.75/2,0,0.75/2,0.75]) translate([x*(housing_h/2+bvm_c*3),y*(bvm_l/2),h/2]) cube([material_t,material_t*5,h],center=true);
		}
		if (0) for (x=[0]) for (y=[-0.65,-0.65/2,0.65/2,0.65]) translate([x*(housing_h/2+bvm_c*3),y*(bvm_l/2),h/2]) cylinder(r=7/2,h=h,center=true);
	}
}
		
		
module base_front(h=material_t) {
	difference() {
		base_front_model(h=h);
		#translate([tft_y_offset,0,h/2]) cube([tft_screen_h,tft_screen_w,h+extra],center=true);
		#for (y=[0:1:3.9]) translate([housing_h/2-bvm_c*3,y*bvm_c*5.5-bvm_c*5.5*1.5,0]) led();
		#for (x=[-1,1]) translate([housing_h/2-bvm_c*3.25,-bvm_l/3.15+bvm_c*3.75*x,0]) button();
		#for (y=[-1,0,1]) translate([housing_h/4*y-housing_h/10,-bvm_l/3.15,0]) rotate([0,0,-90]) pot();
		#for (x=[-1,1]) translate([-housing_h/4-housing_h/10,bvm_l/10*x,0]) rotate([0,0,180]) pot();
	}
}
module h_bridge(h=material_t) {
	translate([0,0,21/2]) cube([32,50,21],center=true);
	for (x=[-1,1]) for (y=[-1,1]) translate([x*40/2-1.2,y*40/2,h]) cylinder(r=cover_bolt_r,h=h*2+extra,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*40/2-1.2,y*40/2,-h/2]) cylinder(r=6/2,$fn=4,h=h,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*2/2-21,y*25/2,-20/2]) cylinder(r=6/2,$fn=4,h=20,center=true);
	#hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*5/2+18,y*5-10,-10/2]) cube([extra,extra,10],center=true);
}
module wiper_motor() {
	motor_x=42;
	motor_y=36;
	translate([y_pos+cam_y_offset,-60/2-material_t*7,-x_pos]) {
		rotate([90,0,0]) cylinder(r=79/2,h=60,center=true);
		translate([-motor_x,-motor_y+60/2,x_pos]) {
			cylinder(r=61/2,h=108,center=true);
			translate([0,0,-30]) cylinder(r=30/2,h=188,center=true);
			translate([61/2+50/2+2/2,0,-1]) rotate([0,0,-90]) h_bridge();
		}
	}
}


module pot(r=7/2,h=material_t) {
	translate([0,0,15.6/2]) cylinder(r=6/2,h=15.6+extra,center=true);
	translate([0,0,7/2]) cylinder(r=7/2,h=7+extra,center=true);
	translate([0,8,h/2]) cube([3,1.5,h+extra],center=true);
	translate([0,0,-9/2-extra]) cylinder(r=17.5/2,h=9,center=true);
	translate([-17.5/2,0,-9/2-extra]) cube([17.5,17.5,9],center=true);
}
module led(r=6/2,h=material_t) {
	translate([0,0,h+2/2]) sphere(r=r-1,center=true);
	translate([0,0,h+1/2]) cylinder(r=r+1,h=1,center=true);
	translate([0,0,h/2]) cylinder(r=r,h=h+extra,center=true);
	translate([0,0,-6/2]) cylinder(r=r+1,h=6,center=true);
}
module button(r=16/2,h=material_t) {
	translate([0,0,h-8/2]) cylinder(r=r,h=8+extra,center=true);
	translate([0,0,h-16/2-extra]) cylinder(r=r-4/2,h=16+extra,center=true);
	translate([0,0,h+8/2+extra]) cylinder(r=r-3/2,h=8,center=true);
	translate([0,0,h+3/2+extra]) cylinder(r=r+3/2,h=3,center=true);
}
module slide_switch(h=material_t) {
	translate([0,0,h/2]) { 
		for (x=[-1,1]) translate([x*9,0,0]) cylinder (r=2/2,h=h+extra,center=true);
		cube([9,4,h+extra*4],center=true);
		translate([0,0,-h/2-1/2-extra]) cube([24,10.5,1],center=true);
		translate([0,0,-h/2-9/2-extra]) cube([16.5,10.5,9],center=true);
		translate([0,0,-h/2-13/2-extra]) cube([9,5.5,13],center=true);
	}
}
module power_jack(r=7/2,h=material_t) {
	translate([0,0,h/2-4]) cylinder(r=r,h=16+extra,center=true);
	translate([0,0,-4/2-extra]) cylinder(r=r*1.5,h=4+extra,center=true);
	translate([0,0,h+2/2+extra]) cylinder(r=r*1.5,h=2+extra,center=true);
}

	
module base_back(h=material_t) {
	difference() {
		base_front_model(h=h);
		
		translate([-housing_h/2*0.0,0,0]) #slide_switch();
		translate([housing_h/2*0.75,0,0]) #power_jack();
		#wiper_motor();
		for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(housing_h/2),y*(material_t*5.5+clearance*2),h/2]) cube([material_t*5,material_t*2,h+extra*4],center=true);
	}	
}	

module base_top(h=material_t) {
	difference() {
		base_bottom(h=h);
		translate([arm_x_offset,bvm_l/2-arm_w*4,0]) cylinder(r=arm_bolt_r,h=h*5+extra,center=true);
		for (x=[-1,1]) translate([arm_x_offset*2*x,0,h/2]) cube([arm_x_offset*2+arm_w*3.5,material_t*3+clearance*2,h+extra],center=true);
	}
}

module bldc_motor_standoff(h=material_t*2) {
	difference() {
		translate([0,-cam_y_offset-motor_body_y_offset,h/2]) cylinder(r=motor_r,h=h,center=true);
		motor_holes(h=h);
	}
}
			
module motor_mount(h=material_t,r=motor_bolt_r+bvm_c*2){
	for (x=[-1,1]) for (y=[0,1]) translate([x*motor_mount_x/2,-cam_y_offset-motor_mount_offset+motor_mount_y*y,h/2]) cylinder(r=r,h=h,center=true);
}


module motor_holes(h=material_t) {
	if (motor_tri) {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (r=[motor_tri_angle,-motor_tri_angle]) rotate([0,0,r]) translate([0,motor_mount_x,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
			translate([0,-motor_mount_y,h/2]) {
				cylinder(r=motor_bolt_r,h=h*2+extra,center=true);
				translate([0,0,material_t*1.5]) cylinder(r=motor_bolt_r*2,h=h*2+extra,center=true);
			}
		}
	} else {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (x=[-1,1]) for(y=[0,1]) translate([x*motor_mount_x/2,-motor_mount_offset+motor_mount_y*y,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
		}
	}
}

module base_wire_holes(h=material_t) {
        for (x=[-0.85,0.85]) translate([x*(x_pos+bvm_c*2),y_pos-housing_h/5.3,h/2]) hull() for (a=[-1,1]) for (b=[-1,1]) translate([bvm_c*a,bvm_c*b*3,0]) cylinder(r=arm_bolt_r,h=h+extra,center=true);
}

module base_hall_holes(h=material_t) {
	translate([0,-cam_y_offset-cam_bearing_offset-bearing_or/2,h/2]) cylinder(r=5/2,h=h+extra,center=true);
}

module base_corners(h=material_t,r=arm_bolt_r,extra=0,x_pos=x_pos) {
	for (x=[-1,1]) for (y=[-1,1]) translate([x*x_pos,y_pos+y*housing_h/2,h/2]) cylinder(r=r,h=h+extra,center=true);
}

module arm_holes(h=material_t) {
	for (x=[-1,1]) translate([x*arm_x_offset,0,h*8/2]) {
		cylinder(r=arm_bolt_r,h=h*8+extra,center=true);
	}
}

module base_end_pin_slots(h=material_t,x_pos=x_pos) {
	for (x=[-1,1]) for (y=[-0.75,0,0.75]) translate([x*(x_pos+bvm_c*3-extra*2),y_pos+y*housing_h/2,h/2]) cube([material_t+extra*4,material_t*5,h],center=true);
	for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*x_pos,y_pos+y*(housing_h/2+bvm_c*3-extra*2),h/2]) cube([material_t*5,material_t+extra*4,h],center=true);
	
	//translate([0,bvm_y_offset,h/2]) cube([bearing_h,bearing_h*1.5,h+extra],center=true);
}

module paddle(laser=0,h=material_t*3) {
	difference() {
		hull() for (y=[-1,1]) for (x=[-1,1]) scale([paddle_scale,paddle_scale,1]) intersection() {
			translate([x*bvm_r/3,y*bvm_r/6,-bvm_r/3+bvm_r/6+bvm_r/60*y]) sphere(r=bvm_r/3,center=true);
			translate([x*bvm_r/3,y*bvm_r/6,bvm_r/3]) cylinder(r=bvm_r/3.75,h=bvm_r/1.5,center=true);
		}
		if (0) union() {
			difference() {
				scale([paddle_scale,paddle_scale,1]) intersection() {
					translate([0,0,-bvm_r/2+bvm_r/6-paddle_t-extra]) sphere(r=bvm_r/2,center=true);
					translate([0,0,bvm_r/2-extra]) cylinder(r=bvm_r/3-paddle_t,h=bvm_r,center=true);
				}
				for (x=[0:bvm_r/8:bvm_r]) translate([-bvm_r/2+x,0,0]) cube([paddle_rib_w,bvm_r,bvm_r],center=true);
				for (y=[0:bvm_r/8:bvm_r]) translate([0,-bvm_r/2+y,0]) cube([bvm_r,paddle_rib_w,bvm_r],center=true);
				hull() {
					for (z=[0,bvm_c*1.5]) translate([0,0,z]) rotate([0,90,0]) cylinder(r=bvm_c*1.5+clearance/2+paddle_rib_w,h=bearing_h+clearance/4+paddle_rib_w*2,center=true);
				}
			}
		}
		if (1) hull() {
			for (z=[0,bvm_c*1.5]) translate([0,0,z]) rotate([0,90,0]) cylinder(r=bvm_c*1.5+clearance/2,h=h+clearance/4,center=true);
		}
	}
}

	


module bearing(outer=bearing_or*2,inner=bearing_ir*2,width=bearing_h) {
	difference() {
		union() {
			color("grey") difference() {
				cylinder(r=outer/2,h=width,center=true);
				cylinder(r=outer/2.3,h=width+extra,center=true);
			}
			color("grey") difference() {
				cylinder(r=inner/1.4,h=width,center=true);
				cylinder(r=inner/2,h=width+extra,center=true);
			}
			color("orange") cylinder(r=outer/2-extra*4,h=width*.9,center=true);
		}
		color("grey") cylinder(r=inner/2,h=width+extra,center=true);
	}
}

module arm_end_support(h=material_t*3,return_spring=0) {
	if (1) translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2]) rotate([0,0,arm_rot/1.5]) difference() {
		hull() {
			translate([arm_w*1.5,-arm_w*3,0]) cylinder(r=arm_w/2,h=h,center=true);
			translate([arm_w/2.6,0,0]) cylinder(r=arm_w/2,h=h,center=true);
			translate([arm_w*1.5,arm_w*3,0]) cylinder(r=arm_w/2,h=h,center=true);
		}
		translate([arm_w,0,0]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
	}
}

module arm_model(h=material_t*3,return_spring=0) {
	c1=arm_w*8.35;
	c2=arm_w*4;
	difference() {
		union() {
			// end_mounts
			if (1) translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2]) {
				rotate([0,0,arm_rot/1.5]) {
					hull() {
						translate([arm_w*1.5,0,0]) cylinder(r=bvm_c*1.5,h=h,center=true);
						translate([arm_w*2.75,-bvm_c,0]) cylinder(r=bvm_c/2,h=h,center=true);
						translate([arm_w*2.75,bvm_c,0]) cylinder(r=bvm_c/2,h=h,center=true);
					}
				}
			}
			arm_end_support(h=h,return_spring=return_spring);
			// return spring experiment
 			if (0) rotate([0,0,arm_rot/2]) translate([arm_x_offset/2.5,cam_y_offset/1.5,h/2]) {
				cube([material_t*5,material_t,h/2],center=true);	
				cube([material_t*2,material_t*3,h/2],center=true);
			}	
			// end curve
			if (1) translate([arm_x_offset,bvm_y_center,h/2]) intersection() {
				difference() {
					translate([c1/2,-c2/2,0]) scale([1,1.2,1]) cylinder(r=bvm_r+c1,h=h,$fn=$fn*2,center=true);
					translate([c2/2,c2,0]) scale([1,1.3,1]) cylinder(r=bvm_r+c2,h=h+extra*2,$fn=$fn*2,center=true);
				}
				hull() {
					rotate([0,0,-25]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*2,h+extra*4],center=true);
					translate([-bvm_r/2,-bvm_r,0]) rotate([0,0,-138]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*4,h+extra*4],center=true);
				}
			}
			// cam drive and bearing mount
			if (1) hull() {
				translate([arm_x_offset+c1/2,bvm_y_center-c2/2,h/2]) scale([1,1.2,1]) rotate([0,0,-64]) translate([0,-bvm_r-c1,0]) cylinder(r=extra,$fn=1,h=h,center=true);
				translate([arm_x_offset+c2/2,bvm_y_center+c2,h/2]) scale([1,1.3,1]) rotate([0,0,-35]) translate([0,-bvm_r-c2,0]) cylinder(r=extra,$fn=1,h=h,center=true);
				translate([0,0,h/2]) cylinder(r=arm_x_offset-clearance,h=h,center=true);
				translate([arm_x_offset-bearing_or,-cam_y_offset,h/2]) {
					translate([bearing_or*.75/2-clearance,0,0])  rotate([0,0,cam_pre_rot]) cube([bearing_or*1.25,cam_l+arm_w*2,h],center=true);
					translate([0,(cam_l/2-bearing_or)*-1,0]) cylinder(r=bearing_or/2, h=h,center=true);
				}
				translate([arm_x_offset-bvm_c*2,-cam_y_offset-cam_l/2-bvm_c,h/2]) cylinder(r=bvm_c,h=h,center=true);
			}
		}
		rot=0;
		// positioning pin holes
		translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2])  rotate([0,0,arm_rot/1.5]) translate([arm_w,0,0]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
		translate([arm_x_offset-bvm_c*2,-cam_y_offset-cam_l/2-bvm_c,h/2]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
		// cam cutout
		if (1) for (i=[0:path_step:180]) {
			if (i<comp_rot) {
				rotate([0,0,i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(h=h+extra,over_h=extra*4,over_r=0,rot=rot);
			} else {
				rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(h=h+extra,over_h=extra*4,over_r=0,rot=rot);
			}
		}
		// bearing cutout
		intersection() {
			translate([0,0,h/2]) cylinder(r=bearing_or+clearance/4,h=h+extra*2,center=true);
			translate([0,0,h/2]) cube([bearing_or*2-clearance/8,bearing_or*2,h+extra*2],center=true);
		}
	}
}

module arm() {
	arm_model();
}
 
module arm_r() {
	mirror([1,0,0]) arm_model();
}
 
module cam(h=material_t,explode=0,d_shaft=d_shaft) {
	union() {
		translate([0,0,-explode]) cam_end_plate(h=material_t*2,d_shaft=d_shaft);
		translate([0,0,material_t*2]) {
			for (y=[-1,1]) translate([0,cam_bearing_offset*y,0]) {
				bearing_washer();
				translate([0,0,explode+bearing_washer_h]) bearing_bushing(h=h);
			}
			translate([0,0,explode]) cam_center(d_shaft=d_shaft,h=material_t*3/2);
			//cam_center(h=bearing_washer_h,d_shaft=d_shaft);
			
		}
	}
}

module cam_model(over_r=0,over_h=0,rot=0) {
	union() { 
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,-cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,-cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r,h=h+over_h,center=true,$fn=16);
		}
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r,h=h+over_h,center=true,$fn=16);
		}
		rotate([0,0,cam_pre_rot]) hull() for(i=[-1,1]) translate([0,cam_bearing_offset*i,h/2]) cylinder(r=bearing_or/1.25+over_r,h=h+over_h,center=true,$fn=8);
	}
}

module cam_plate(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		union() {
			for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or-clearance*3,h=h,center=true);
			hull() for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or/1.25,h=h,center=true);
		}
		cam_holes(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
	}
}

module cam_end_plate(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		hull() {
			cam_plate(h=h,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
			translate([0,0,h/2]) cylinder(r=cam_l/2,h=h,center=true);
		}
		cam_holes(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
	}
}

module cam_holes(d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	// bolt/studs
	for(y=[-1,1]) translate([0,cam_bearing_offset*y,cam_h/4]) cylinder(r=cam_bolt_r,h=cam_h,center=true);
	// shaft
	rotate([0,0,(d_shaft-1)*0]) intersection() {
		translate([0,0,cam_h/2]) cylinder(r=motor_shaft_r+clearance/4,h=cam_h+extra,center=true);
		if (d_shaft > 0 )translate([0,motor_shaft_r/2-motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		if (d_shaft > 1) translate([0,-motor_shaft_r/2+motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		//%cube([8.25,8.25,8.25],center=true);
	}
}

module cam_encoder(h=material_t/3,r=cam_l/2+bvm_c*2) {
	translate([0,0,h/2]) difference() {
		cylinder(r=r,h=h,center=true);
		for (a=[1:1.8:179]) rotate([0,0,a]) for (b=[1,-1]) translate([(r-4)*b,0,0]) cube([4,kerf*3,h+extra],center=true);
		cylinder(r=motor_bolt_r,h=h+extra,center=true);
	}
} 	


module cam_center(h=material_t*3,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		cam_plate(h=h,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
		for(i=[-1,1]) translate([0,cam_bearing_offset*i,h/2]) {
			cylinder(r=bearing_or+clearance,h=h+extra,center=true);
			cube([bearing_or*2,bearing_or*1.5,h+extra],center=true);
		}
	}
}
	

