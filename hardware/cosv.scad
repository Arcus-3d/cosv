/*	Project name:		COSV - Cam Open Source Ventilator
	Project home: 		https://hackaday.io/project/170507
	Project repo: 		https://github.com/Arcus-3d/cosv
	Project authors: 	Daren Schwenke, Steven Carr

	Software license: 	http://www.gnu.org/licenses/gpl-3.0.html
	Hardware license: 	https://ohwr.org/cern_ohl_s_v2.txt
	Hardware note: 		Defensive patents for the relevant novel hardware elements of this project have been filed.  
				Kindly follow our Open Source Hardware licensing requirements. Thank you.
	Project version: 	0.20
	Version note: 		The *vast* majority of files which have been recently generated target equal height/multiple millimeter based layer construction.
				In other words, if you are not laser cutting this from sheet stock around 3mm thick for all but paddle() and flow_sensor_venturi_for_pcb()
				you may have issues.
 				There are *very* likely artifacts for the FFF and milled version of the files you can generate.
 				Please do a little sanity check if you generate your own FFF or milled files please.  
				If you are looking at a rendered file in the repository, it should be the latest version.	
	Abbreviations:
				r=radius (and sometimes rotation within modules)
				ir=inner radius
				or=outer radius
				t=thickness
				l=length
				h=height
				w=width
				d=depth
				x,y,z=dimensions in x,y,z
*/



/* [Global] */

/* [COSV Customization] */
// Circle complexity: Turn down to about 30 for working, up to like 90 for rendering
param_complexity=30; // [1:100]

// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this. Smaller values result in smoother, but more complicated surfaces.  A good value for working is 15. A good value for rendering is 2-5.
param_path_step=15; // [1:15]

// Line width for laser cutting.  Affects hole sizes
//param_kerf=0.15; // [0.000:0.005:0.500]
param_kerf=0.04; // [0.000:0.005:0.500]

// Motor mount selection
param_motor="wiper"; // [wiper:Ford F150 Wiper Motor,bldc:BLDC Brushless Motor,worm:Worm gear motor,nema23:Nema23 Stepper with 6mm shaft,nema23-635:Nema23 Stepper with 6.35mm shaft]

// Is the motor shaft D-Shaped?
param_d_shaft = "auto"; // [zero:Circular,one:D-Shaped,two:Double-D shaped (wiper motor),auto:D or DD based on motor type]

// Which one would you like to see?
param_part = ""; // REPLACE_ME_PART_TRAP_EM_ECALPER 

/* [Hidden] */


// Don't touch $fn, the param_complexity variable is over-ridden in the makefile
$fn=param_complexity;


// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface
// while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this.
// Smaller values result in smoother, but more complicated surfaces.  
// A good value for working is 15. A good value for rendering is 1.
path_step=param_path_step; // [1:15]

PART=param_part;


//////////////////////////////////////////////////////////////////
// Assembly views, for testing
//rotate([90,0,0]) cosv_assembly_view(cam_angle=$t*180,explode=30);
//cam_assembly_view(explode=0);
//flow_sensor_assembly_view(rot=360*$t,explode=0.1);

//////////////////////////////////////////////////////////////////
// Laser parts, for testing

//laser_base_mount_left(); // GROUP Laser DESC "cam/arm mount opposite motor" 
//laser_base_mount_right(); // GROUP Laser DESC "cam/arm mount motor side"

//laser_arm(path_step=1,$fn=90); // GROUP Laser DESC  "arm for the bag" NAME="laser_arm" QTY 6
//laser_arm_end_support(); // GROUP Laser DESC "small support triangles for the paddle from the arm" QTY 16

//laser_base_end_right(slots=0,battery=0); // GROUP Laser DESC "outer end plate with bvm_br sized bag hole" NAME="laser_base_end_right"
//laser_base_end_left(slots=0,battery=0); // GROUP Laser DESC "outer end plate with bvm_tr sized bag hole" NAME="laser_base_end_left"

//laser_base_end_right(slots=1,battery=0); // GROUP Laser DESC  "inner end plate with bvm_br sized bag hole" NAME="laser_base_end_right_with_slots"
//laser_base_end_left(slots=1,battery=1); // GROUP Laser DESC "inner end plate with bvm_tr sized bag hole" NAME="laser_base_end_left_with_slots"

//laser_base_battery_mount_t(); // GROUP Laser DESC  "battery mounts"
//laser_base_battery_mount_b(); // GROUP Laser DESC  "battery mounts"

//laser_arm_mount(motor=1); //  GROUP Laser DESC "bushings from cam/arm mount to the arm bearings, with a hole for the motor mount" NAME="laser_arm_motor_mount" QTY 3
//laser_arm_mount(motor=0); //  GROUP Laser DESC "bushings from cam/arm mount to the arm bearings" NAME="laser_arm_mount" QTY 3

//laser_base_front_analog(); //  GROUP Laser DESC "front panel for analog controls and small SPI display"
//laser_base_front_pi(layer=0); // GROUP Laser DESC "front panel for pi touchscreen.  Three layers required." NAME="laser_base_front_pi_0"
//laser_base_front_pi(layer=1); // GROUP Laser DESC "front panel for pi touchscreen.  Three layers required." NAME="laser_base_front_pi_1"
//laser_base_front_pi(layer=2); // GROUP Laser DESC "front panel for pi touchscreen.  Three layers required." NAME="laser_base_front_pi_2"

//laser_base_front(); // GROUP Laser DESC "base front inner panel"
//laser_base_back(); // GROUP Laser DESC "base back inner panel"
//laser_base_back_wiper(); // GROUP Laser DESC "base back panel for wiper motor, h-bridge, switch, and power plug"

//laser_cam_end_plate_b(); // GROUP Laser DESC "cam end plate motor side" NAME="laser_cam_end_plate_wiper_6mm" QTY 2
//laser_cam_end_plate_t(); // GROUP Laser DESC "cam end plate opposite motor" NAME="laser_cam_end_plate_wiper_double_d" QTY 2

//laser_cam_center_b(); // GROUP Laser DESC "cam center with motor shaft cutout"
//laser_cam_center_t(); // GROUP Laser DESC "cam center with motor shaft bolt cutout"
//laser_bearing_kerf_test(); // GROUP Test DESC "Laser bearing kerf test"
//laser_cam_encoder(); // GROUP Laser DESC "cam end with encoder slots for optical gate"

//laser_base_top(); // GROUP Laser DESC "top panel with rj45 jack and holes for arms"
//laser_base_bottom(); // GROUP Laser DESC "bottom panel"

//laser_bearing_bushing(ir=4/2,or=8/2); // GROUP Laser DESC "bushing for cam bearings" NAME="laser_bearing_bushing_4x8mm" QTY 6
//laser_bearing_bushing(ir=6/2,or=8/2); // GROUP Laser DESC "bushing for motor shaft bearing" NAME="laser_bearing_bushing_6x8mm" QTY 3

//laser_paddle(layer=0,h=material_t*3); // GROUP Laser DESC "paddles for the arms." NAME="laser_paddle_0" QTY 4
//laser_paddle(layer=1,h=material_t*3); // GROUP Laser DESC "paddles for the arms." NAME="laser_paddle_1" QTY 2

//laser_nut_support(); // GROUP Laser DESC "little glue-on nut holder to eliminate a whole layer otherwise" QTY 8

//////////////////////////////////////////////////////////////////
// FFF parts, for testing.  May be out of date!

//flow_sensor_pitot_for_pcb(); // GROUP VISP DESC "Flow Sensor Pitot Style"
//flow_sensor_venturi_for_pcb(); //  GROUP VISP DESC "Flow Sensor Venturi Style"
//flow_sensor_cover(oled=0); //  GROUP VISP DESC "Flow Sensor Cover With OLED" NAME "flow_sensor_cover_oled"
//flow_sensor_cover(); // GROUP VISP DESC "Flow Sensor Cover"

//cam(); // cam top/bottom.
//cam_encoder(h=0.5);

paddle(); // paddle for the arms.

//arm();

//base_mount_left();
//base_mount_right();

//base_end_left(battery=1); 
//base_end_right(); 

//base_front();
//base_front_analog();
//base_front_pi(layer=1);

//base_battery_mount_t();
//base_battery_mount_b();
//base_back();
//base_back_wiper();

//base_top();
//base_bottom();

//bearing_bushing();
//bearing_washer();

//supply_cover();
//bldc_motor_standoff(); // bldc motor has a long pilot on it, which requires a standoff

//arm_end_lock(); // in progress

//////////////////////////////////////////////////////////////////
// Part models, for testing
//optical_gate();
//base_plate(); // top plate/electronics mount.  Need 1.
//flow_sensor_test();

// Clearance for parts, and extra length to make subtractions clean.
clearance=0.4;
extra=0.02;

// nozzle size for 3D printing.  Generates parts that are exactly a multiple of this width for strength
nozzle_r=0.4/2;

// line width for laser cutting.  Affects hole sizes (param_kerf is CLI overridden by Makefile)
kerf=param_kerf;

// material thickness for laser cutting
material_t=3.175;

arm_w=12*nozzle_r*2; 
arm_h=material_t*3;
bearing_or=22/2-kerf;
bearing_ir=8/2+kerf;
bearing_h=7;

// bag dimensions and position
bvm_r=125/2;
bvm_br=62/2;
bvm_tr=41/2;
bvm_l=200;
bvm_c=nozzle_r*2*8; // Thickness for bag parts
bvm_y_offset=30; // Moves the bag location up/down
bvm_y_center=bvm_r+bearing_or/2+bvm_y_offset+arm_w*2;

// a little washer to clearance the bearing
bearing_washer_h=(arm_h-bearing_h)/2;

// assembly bolt size
cam_bolt_r=4/2+clearance/4-kerf;
arm_bolt_r=8/2+clearance/4-kerf;
cover_bolt_r=3/2-kerf;
wire_t=1.25;

// compression rotation angle.  You *could* generate uneven compression/release profiles with this for a weaker motor, or to have hardware ratio of inhale/exhale and a static motor.
// This doesn't work very well as your max angle is still > 120, and is currently ignored as the arms are generated as mirror images.  Saving just in case..
comp_rot=90;

// paddle dimensions.  Low infill part.
paddle_x=bvm_r/2;
paddle_y=bvm_r/3;
paddle_t=bvm_c*1.34;

// how far the arm rotates with a full comp_rot
arm_rot=30; 
// how far apart the arm bearings are from the centerline
arm_x_offset=22;

// mechanical dimensions for the cam action
cam_bearing_offset=22;
cam_l=cam_bearing_offset*2+bearing_or*2;
cam_h=material_t*7;
cam_y_offset=bearing_or+cam_l/2+arm_w;
cam_pre_rot=-0;

// overall inner housing dimensions
housing_h=cam_l+cam_y_offset;
// corner locations
x_pos=bvm_r+bvm_c*6;
y_pos=bvm_y_center-bvm_r-bvm_c*4-housing_h/2;
// recess for the front/back panels
front_recess=arm_w*2;

// little box to cover our supply ends
supply_cover_x=38;
supply_cover_y=98;
supply_cover_z=20;
supply_cover_t=1.6;

// pitot/venturi tube dimensions
// outer tube.  This is the dia of the mask, generally
tube_or=22/2;
tube_taper=nozzle_r;
tube_ir=tube_or-nozzle_r*2*6;
// depth of the socket/tube
tube_d=19;

pcb_t=1.6+3.2+clearance; // Board is 1.6, OLED is 5.2mm tall.  Recess in lid is 2mm.
pcb_c_t=2.4;
pcb_b=1.6;
pcb_x=21+clearance;
pcb_y=47+clearance;
pcb_z_offset=4;
pcb_port_z_offset=8;
pcb_port_z_spacing=4;
pcb_port_x_spacing=4;
pcb_bolt_spacing=24;
pcb_cover_t=2.8;
pcb_cable_t=1.5;

// total length
tube_l=tube_d*2+(pcb_y-tube_d)+pcb_z_offset+tube_d*1.25;
// venturi section length
vent_l=tube_l/1.35;
// venturi center section length
vent_h=vent_l/6;
// venturi restriction radius
vent_r=6.5/2;

// pitot tube dimensions
pitot_r=6/2;
pitot_t=nozzle_r*2*3;
port_r=5.5/2;
pitot_snap_offset=.05;

// visp oled dimensions
oled_x=12+clearance;
oled_y=39+clearance;
oled_pin_h=1;
oled_t=2+oled_pin_h;
oled_glass_x=9;
oled_glass_x_offset=-1;
oled_glass_y=26;

// param_motor is defined at the top of the file (and over-ridden by CLI in Makefile)
MOTOR=param_motor;

// Support makefile passing this in, we have rendered each motor have D or !D shaped for the cams
d_shaft = (param_d_shaft=="zero" ? 0 : 
          (param_d_shaft=="one" ? 1 :
	  (param_d_shaft=="two" ? 2 :
	  (param_d_shaft=="auto" ? (MOTOR=="wiper" ? 3 : (MOTOR=="worm" ? 1 : (MOTOR=="nema23" ? 1 : 0))) : 0))));
motor_tri = (MOTOR=="wiper" ? 1 : 0);
motor_tri_angle = (MOTOR=="wiper" ? 53 : 60);
motor_mount_offset = (MOTOR=="wiper" ? 0
                   : (MOTOR=="worm" ? 9
                   : (MOTOR=="nema23" ? 47.1/2
                   : (MOTOR=="nema23-635" ? 47.1/2
                   : (MOTOR=="bldc" ? 6.25 : 0)))));
motor_mount_x = (MOTOR=="wiper" ? -35
              : (MOTOR=="worm" ? 18
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 15.5 : 0)))));
motor_mount_y = (MOTOR=="wiper" ? -46
              : (MOTOR=="worm" ? 33
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 26.75 : 0)))));
motor_r = (MOTOR=="wiper" ? 54
        : (MOTOR=="bldc" ? 37/2 : 0));
motor_bolt_r = (MOTOR=="wiper" ? 6/2+clearance/4-kerf
             : (MOTOR=="worm" ? 3/2+clearance/4-kerf
             : (MOTOR=="nema23" ? 4/2+clearance/4-kerf
             : (MOTOR=="nema23-635" ? 4/2+clearance/4-kerf
             : (MOTOR=="bldc" ? 3/2+clearance/4-kerf : 0))))); 
motor_pilot_r = (MOTOR=="wiper" ? 24/2+clearance-kerf
              : (MOTOR == "worm" ? 6/2+clearance-kerf
              : (MOTOR == "nema23" ? 38.1/2+clearance-kerf
              : (MOTOR == "nema23-635" ? 38.1/2+clearance-kerf : 0))));
motor_shaft_r = (MOTOR=="wiper" ? 12/2+clearance/4-kerf
              : (MOTOR == "worm" ? 6/2-kerf
              : (MOTOR == "nema23" ? 8/2-kerf
              : (MOTOR == "nema23-635" ? 6.35/2-kerf
              : (MOTOR=="bldc" ? 6/2-kerf : 0)))));
motor_shaft_flat_x = (MOTOR=="wiper" ? 8.1/2 : 0);
motor_shaft_flat_y = (MOTOR=="wiper" ? 11/2 : 0);
motor_body_y_offset = (MOTOR=="bldc" ? -7 : 0);


module laser_base_mount_left() {
	projection(cut=false) base_mount_left();
}
module laser_base_mount_right() {
	projection(cut=false) base_mount_right();
}
module laser_bearing_washer() {
	projection(cut=true) bearing_washer();
}
module laser_cam_end_plate_b() {
	projection(cut=true) cam_end_plate();
}
module laser_cam_end_plate_t() {
	projection(cut=true) cam_end_plate(motor_shaft_r=6/2,d_shaft=0);
}
module laser_cam_center_b() {
	projection(cut=true) cam_center();
}
module laser_cam_encoder() {
	projection(cut=false) cam_encoder();
}
module laser_cam_center_t() {
	projection(cut=true) cam_center(motor_shaft_r=6/2,d_shaft=0);
}
module laser_arm_mount(motor=0) {
	projection(cut=true) difference() {
		arm_mount(motor=motor);
		if (motor) translate([0,0,-material_t*2]) motor_holes();
	}
}
module laser_arm($fm=90,path_step=1) {
	//arm_model();
	projection(cut=true) arm_model($fn=$fn,path_step=path_step);
}
module laser_arm_end_support(h=material_t) {
	projection(cut=false) arm_end_support(h=h);
}
module laser_arm_end_lock(h=material_t) {
	projection(cut=true) arm_end_lock(h=h);
}
module laser_paddle(layer=0,h=material_t*3) {
	paddle_x=paddle_x+material_t*2;
	paddle_y=paddle_y+material_t*2;
	projection(cut=true) translate([0,0,-layer*material_t]) paddle(paddle_x,paddle_y,h=h);
}
module laser_bearing_bushing(ir=cam_bolt_r,or=bearing_ir) {
	projection(cut=true) bearing_bushing(ir=ir,or=or);
}
module laser_base_end_right(slots=1) {
	projection(cut=false) base_end_right(slots=slots);
}
module laser_base_bottom() {
	projection(cut=true) base_bottom();
}
module laser_base_top() {
	projection(cut=true) base_top();
}
module laser_base_front_analog() {
	projection(cut=true) base_front_standalone();
}
module laser_base_front() {
	projection(cut=true) base_front();
}

module laser_base_front_pi(layer=0) {
	projection(cut=true) base_front_pi(layer=layer);
}
module laser_base_back() {
	projection(cut=true) base_back();
}
module laser_base_back_wiper() {
	projection(cut=true) base_back_wiper();
}

module laser_base_end_left(slots=1,battery=1) {
	projection(cut=false) base_end_left(slots=slots,battery=battery);
}

module laser_base_battery_mount_t() {
	projection(cut=false) base_battery_mount_t();
}

module laser_base_battery_mount_b() {
	projection(cut=false) base_battery_mount_b();
}

module laser_base_end_right(slots=1,battery=1) {
	projection(cut=false) base_end_right(slots=slots,battery=battery);
}
module laser_base_mount_right() {
	projection(cut=false) base_mount_right();
}
module laser_callibration_square(w=10) {
	projection(cut=true) cube([w,w,w],center=true);
}
module laser_bldc_motor_standoff() {
	projection(cut=true) bldc_motor_standoff();
}
module laser_nut_support(r1=6.25/2,r2=6) {
	projection(cut=true) nut_support(r1=r1,r2=r2,h=h);
}
module laser_bearing_kerf_test() {
	$fn=90;
	bearing_or=22/2;
	for (x=[0:0.025:0.25]) translate([-bearing_or*20/2+bearing_or/0.025*2.3*x,0]) {
		difference() {
			square([bearing_or*2.5+extra,bearing_or*3.5],center=true);
			translate([0,1]) circle(r=22/2-x,center=true);
			translate([0,bearing_or+2]) text(text=str(x),size=4,halign="center");
			translate([0,-bearing_or-3]) square([bearing_or*2,material_t],center=true);
		}
	}
}
// now a little screwed up since I split the parts into layers
module cosv_assembly_view(explode=0,cam_angle=0) {
	if (0) translate([0,bvm_y_center,0]) {
	//if (0) {
		//$fn=32;
		if (cam_angle < comp_rot) {
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		} else { 
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		}
	}
	if (1) translate([0,bvm_y_center+bvm_r*1.15,0]) cylinder(r=arm_bolt_r*2,h=bvm_l,center=true);
	if (1) translate([0,bvm_y_center+bvm_r*1.15,0]) %cylinder(r=arm_bolt_r,h=bvm_l+bvm_c*3,center=true);
	if (1) translate([0,0,-bvm_l/2-material_t-explode*4]) base_end_right(slots=0,battery=0);
	if (1) translate([0,0,-bvm_l/2-explode*3]) base_end_right();
	if (1) translate([0,0,-cam_h/2-material_t*3-clearance*2]) base_mount_right();
	if (1) translate([0,y_pos-housing_h/2-bvm_c*3+material_t/2-explode,0]) rotate([90,0,0]) base_bottom();
	if (1) translate([0,y_pos+housing_h/2+bvm_c*3+material_t/2+explode/4,0]) rotate([90,0,0]) base_top();
	if (1) translate([x_pos+bvm_c*3-material_t/2-front_recess+explode,y_pos,0]) rotate([90,0,90]) {
		base_front();
		for (i=[0,1,2]) translate([0,0,material_t*(i+1) +explode*(i+1)]) base_front_pi(layer=i);
	}
	if (1) translate([-x_pos-bvm_c*3+material_t/2+front_recess-explode,y_pos,0]) rotate([90,0,270]) base_back();
	if (1) translate([-x_pos-bvm_c*3+material_t/2+material_t+front_recess-explode*2,y_pos,0]) rotate([90,0,270]) base_back_wiper();
	if (1) translate([0,0,cam_h/2+material_t*3+clearance*2]) rotate([0,180,0]) base_mount_left();
	if (1) translate([0,0,bvm_l/2+explode*3]) rotate([0,180,0]) base_end_left();
	if (1) translate([0,0,+bvm_l/2+material_t+explode*4]) rotate([0,180,0]) base_end_left(slots=0,battery=0);
	if (1) translate([0,0,bvm_l/2]) base_battery_mount_t();
	if (1) translate([0,0,bvm_l/2]) base_battery_mount_b();
	if (1) translate([0,0,bvm_l/2]) %battery();
	if (1) translate([0,-cam_y_offset,0]) rotate([0,0,-cam_angle+416322cam_pre_rot]) cam_assembly_view(explode=0);
	if (1) translate([0,0,-bvm_l/2-bvm_c*3/2]) %base_corners(x_pos=x_pos-front_recess,r=arm_bolt_r,h=bvm_l+bvm_c*3);
	if (1) translate([arm_x_offset,0,-material_t]) {
		translate([0,0,bearing_h/2+extra/2]) bearing();
		if (cam_angle < comp_rot) {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,cam_angle/(comp_rot/arm_rot)]) {
				arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w,bvm_y_center,material_t*3/2]) rotate([0,-90,0]) translate([0,bvm_c,-paddle_t]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		} else {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-cam_angle/(comp_rot/arm_rot)]) {
				arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w,bvm_y_center,material_t*3/2]) rotate([0,-90,0]) translate([0,bvm_c,-paddle_t]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		}
	}
	if (1) translate([-arm_x_offset,0,-material_t]) {
		translate([0,0,bearing_h/2+extra/2]) bearing();
		if (cam_angle < comp_rot) {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,-cam_angle/(comp_rot/arm_rot)]) {
				arm();
				if (1) translate([arm_x_offset-bvm_r-arm_w,bvm_y_center,material_t*3/2]) rotate([0,90,0]) translate([0,bvm_c,-paddle_t]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		} else {
			translate([0,0,bearing_h/2-material_t*3/2]) rotate([0,0,-comp_rot/(comp_rot/arm_rot)*2+cam_angle/(comp_rot/arm_rot)]) {
				arm();
				if (1) translate([arm_x_offset-bvm_r-arm_w,bvm_y_center,material_t*3/2]) rotate([0,90,0]) translate([0,bvm_c,-paddle_t]) rotate([-arm_rot/1.5,0,0]) paddle();
			}
		}
	}
}


module flow_sensor_assembly_view(explode=0,rot=0) {
	vent_t=tube_or-tube_ir;
	rotate([0,0,rot]) {
		flow_sensor_venturi_for_pcb();
		translate ([0,vent_t+explode,0]) flow_sensor_cover_model(oled=1);
	}
}

module cam_assembly_view(explode=0) {
	translate([0,0,-explode*2-material_t*7/2]) cam(explode=explode);
	for(i=[-1,1]) translate([0,cam_bearing_offset*i,0]) bearing();
	translate([0,0,explode*2+material_t*7/2]) rotate([0,180,0]) cam(h=material_t,explode=explode);
	translate([0,0,explode*2+material_t*7/2+extra]) cam_encoder(h=material_t);
}
module flow_sensor_cover(oled=0) {
	t=tube_or-tube_ir;
	translate([0,-tube_l/2-tube_d/1.5,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t/2+pcb_b]) rotate([-90,0,0]) flow_sensor_cover_model(oled=oled);
}

module supply_cover() {
	difference() {
		union() {
			translate([0,0,supply_cover_z/2]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z],center=true);
			translate([0,arm_bolt_r+supply_cover_t+clearance/2,supply_cover_z/4]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z/2],center=true);
			hull() {
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r*2,h=supply_cover_x+supply_cover_t*2,center=true);
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r/2,extra/2]) cube([supply_cover_x+supply_cover_t*2,extra,extra],center=true);
			}
			
		}
		translate([0,0,supply_cover_z+supply_cover_t]) cube([supply_cover_x,supply_cover_y,supply_cover_z*2],center=true);
		translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r+clearance/2,h=supply_cover_x+supply_cover_t*2+extra,center=true);
		for (y=[-1,1]) translate([0,supply_cover_y*0.25*y,supply_cover_t/2]) cylinder(r=5.4/2,h=supply_cover_t*4,center=true);
	}
}
module flow_sensor_cover_model(oled=0) {
	t=tube_or-tube_ir;
	vent_t=t;
	if (1) difference() {
		union() {
			hull() for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t+pcb_c_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) {
				rotate([90,0,0]) cylinder(r=pcb_b/2,$fn=$fn/2,h=extra,center=true);
				translate([x*-0.1,pcb_cover_t-pcb_b/2,0]) sphere(r=pcb_b/2,$fn=$fn/2,center=true);
			}
			translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2+wire_t,tube_l-pcb_b*5/2]) difference() {
				translate([0,-pcb_t/2,0]) cube([pcb_x/3-clearance,pcb_c_t+pcb_cover_t,pcb_b*5+extra],center=true);
				translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
				translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
			}
			// oled rim
			translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset-pcb_b*1.5]) cube([pcb_x-clearance,oled_t/2+extra,oled_y+pcb_b*4],center=true);
			// cover mount
			translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t-pcb_cover_t*0.85,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
				cube([pcb_x-clearance,extra,pcb_b*2.5-clearance/2],center=true);
				rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2-clearance/2,h=pcb_x-clearance,center=true);
			}
		}
		// oled pocket
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b+extra,oled_y+clearance],center=true);
		// oled pins
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2+oled_pin_h,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset+oled_y/2-pcb_b]) cube([oled_x+clearance,oled_t+pcb_b/2+extra,oled_t+pcb_b*2],center=true);
		// oled display opening
		if (oled) translate([oled_glass_x_offset,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset]) hull() {
			cube([oled_glass_x+t*2,extra,oled_glass_y+t*2],center=true);
			translate([0,-t,0]) cube([oled_glass_x,extra,oled_glass_y],center=true);
		}
		// screw holes
		// cover screw holes
		for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
			rotate([90,0,0]) cylinder(r=cover_bolt_r+clearance/4,h=pcb_t+pcb_c_t+t,center=true);
			translate([0,pcb_cover_t*2,0]) rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
		}
		//translate([0,tube_or+t+pcb_t+pcb_c_t+oled_t/2-pcb_b,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b*2+extra,oled_y+clearance],center=true);
	}
}

module flow_sensor_venturi_for_pcb(sla=1) {
	t=tube_or-tube_ir;
	vent_t=-t/2;
	difference() {
		if (1) union() { // Change to 0 to see all the cutouts
			// body bottom
			for (r=[0,90,180,270]) rotate([0,0,r]) hull() {
				translate([0,tube_or-tube_or/2,tube_d*1.05]) cylinder(r=tube_or/2+tube_taper,h=extra,center=true);
				translate([0,tube_or-tube_or/2,extra]) cylinder(r=tube_or/2,h=extra,center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// body top 
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t/2+pcb_c_t/2+vent_t,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
				translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) sphere(r=port_r/2+nozzle_r*20,center=true);
			}
		}
		difference() {
			if (1) union() {
				// cover screw holes
				for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=pcb_t+pcb_c_t+t+cover_bolt_r*2,center=true);
					translate([0,pcb_cover_t*2,0]) {
						rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
						hull() {
							translate([0,-cover_bolt_r*8.5,0]) sphere(r=cover_bolt_r-clearance/4,center=true);
							translate([0,-cover_bolt_r*6,-cover_bolt_r*6]) sphere(r=cover_bolt_r-clearance/4,center=true);
						}
					}
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2+vent_t,tube_l-pcb_b*3-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t-nozzle_r*4+extra*2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(nozzle_r*4) {
						translate([0,pcb_t*1.15]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,-pcb_t*0.15,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=tube_or*2+t*2+extra,center=true);
				}
				// venturi
				translate([0,0,t/8]) cylinder(r2=tube_ir,r1=tube_ir+t/4,h=t/4+extra,center=true);
				translate([0,0,tube_d/2]) cylinder(r=tube_ir,h=tube_d+extra,center=true);
				translate([0,0,tube_l/2]) {
					translate([0,0,-vent_l/4-vent_h/2-vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
					translate([0,0,-vent_l/8-vent_h/2]) cylinder(r1=tube_ir,r2=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,0]) cylinder(r=vent_r,h=vent_h+extra,center=true);
					translate([0,0,vent_l/8+vent_h/2]) cylinder(r2=tube_ir,r1=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,vent_l/4+vent_h/2+vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
				}
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					rotate([0,0,45]) hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t*1.1+vent_t,tube_l-pcb_b*5/2]) difference() {
					translate([0,-pcb_t/2,0]) cube([pcb_x/3+clearance/2,pcb_c_t+pcb_cover_t,pcb_b*20+extra],center=true);
					translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
					translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				translate([0,vent_t,0]) difference() {
					union() {
						if (1) hull() {
							translate([0,tube_or+t,tube_l-pcb_t-pcb_c_t-pcb_t-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t,tube_l-(pcb_y+pcb_b*5.25-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-vent_t-pcb_b*3.5+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
						}
						if (1) hull() {
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-pcb_y-pcb_z_offset-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t+pcb_c_t,tube_l-pcb_y+pcb_z_offset]) cube([pcb_x,extra,pcb_port_z_offset*2+pcb_b*2],center=true);
						}
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=t*5,center=true);
					hull() {
						translate([0,-t*5/2,0]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
						translate([cover_bolt_r/1.25,-t*8.8/2,-t/2]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
					}
				}
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*1.25;
				// ports
				translate([0,vent_t,0]) {
					translate([-pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
						translate([0,-pcb_c_t/2,-port_r/8]) rotate([90,0,0]) scale([1.25,1,1]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,port_r/2]) sphere(r=port_r/1.5,center=true);
					}
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/2]) sphere(r=port_r/1.5,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4+t-vent_t,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) sphere(r=port_r/2.75,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4+t-vent_t,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2.75,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset+port_r/2]) sphere(r=port_r/1.5,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4+t-vent_t,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) sphere(r=port_r/2.75,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4+t-vent_t,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2.75,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						for (x=[1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) translate([0,-pcb_c_t*2.5,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
						translate([pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset+port_r/2]) sphere(r=port_r*1.25,center=true);
						translate([0,-vent_t,tube_l/2]) rotate([0,0,-20]) translate([0,vent_r*1.5,0])  scale([1.25,1,3]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
					}
					translate([0,-vent_t,tube_l/2]) rotate([0,0,-20]) translate([0,vent_r*0.75,0])  scale([1.25,1,3]) rotate([90,0,0]) cylinder(r=port_r/2,h=vent_r*1.5,center=true);
					translate([pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) scale([1.25,1,1]) cylinder(r=port_r,h=pcb_c_t,center=true);
					}
					translate([pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t,port_r-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
						translate([0,-pcb_c_t,-port_r/6]) rotate([90,0,0]) scale ([1.25,1,1]) cylinder(r=port_r,h=extra,center=true);
						translate([0,i,port_r/2]) sphere(r=port_r*1.25,center=true);
					}
					translate([-pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) scale([1.25,1,1]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,-port_r/2]) sphere(r=port_r/1.5,center=true);
					}
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		if (sla) for (r=[90]) rotate([0,0,r]) translate([tube_ir+t/2,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=t*2,center=true);
	}
}
module flow_sensor_pitot_for_pcb() {
	t=tube_or-tube_ir;
	difference() {
		if (1) union() {
			// bottom taper
			for (r=[0,90]) rotate([0,0,r]) hull() {
				translate([0,0,tube_d*1.05]) cube([tube_or*2+tube_taper*2,t,extra],center=true);
				translate([0,0,extra/2]) cube([tube_or*2-clearance/2,t,extra],center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// bottom bevel.  SLA printers didn't like this...
			//translate([0,0,t/4]) cylinder(r1=tube_or-t/4,r2=tube_or,h=t/2,center=true);
			// top
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				//translate([0,0,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset]) cylinder(r=tube_or+t,h=pcb_y+pcb_b*2+pcb_z_offset*2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(pcb_x+pcb_b)/2*x,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
// cube([pcb_x+pcb_b*2,pcb_t+pcb_c_t,pcb_y+pcb_b*2+pcb_z_offset*2],center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
			}
		}
		difference() {
			if (1) union() {
				// screw holes
				for (x=[-1,1]) for (z=[1]) translate([(pcb_x+pcb_b-t*3)/2*x,tube_or+t*2.8+pcb_cover_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2-t*2.5)/2*z]) {
					rotate([90,0,0]) cylinder(r=3/2-clearance,h=pcb_t+pcb_c_t+t,center=true);
					translate([0,pcb_cover_t,0]) rotate([90,0,0]) cylinder(r1=3/2,r1=3,h=3,center=true);
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2,tube_l-pcb_b*2-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t/2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(1) {
						translate([0,pcb_t]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=pcb_x*2,center=true);
				}
				// center cutout
				translate([0,0,tube_l/2]) cylinder(r=tube_ir,h=tube_l+extra*2,center=true);
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) difference() {
					cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset+extra],center=true);
					translate([0,-pcb_t/2-pcb_c_t/2-pcb_cover_t/2,-t/2]) rotate([0,90,0]) cylinder(r=t/3,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				difference() {
					union() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b-pcb_port_z_offset)/2]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_t/2+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([pcb_x,pcb_t+extra,pcb_y+pcb_b+extra],center=true);
					}
					difference() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-pcb_b]) rotate([-45,0,0]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset*2+extra],center=true);
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/2,h=t*3.75,center=true);
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*3;
				// ports
				for (x=[-1,1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				for (x=[-1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
			rotate([0,0,25]) { // if you alter the depth of the ports, this needs to change and I'm too lazy to do that math.
				translate([0,0,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset]) intersection() {
					union() {
						for (r=[1,0]) mirror([0,0,r]) translate([0,tube_ir,tube_ir+pcb_port_z_spacing]) rotate([0,90,0]) difference() {
							union() {
								rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r+pitot_t,center=true);
								translate([tube_ir/2+pcb_port_x_spacing/2,(-tube_or-t)/2,0]) cube([tube_ir+pcb_port_x_spacing,tube_or+t+pitot_r+pitot_t-pcb_b,pitot_t],center=true);
							}
							rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
						}
					}
					translate([0,(tube_ir+t-pitot_r-pitot_t-pcb_b)/2+clearance/4,0]) cube([tube_ir,tube_ir+t+pitot_r+pitot_t-pcb_b,(tube_ir+pcb_port_z_spacing)*2],center=true);
				}
				if (1) difference() {
					h=tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset-nozzle_r-(tube_ir+pcb_port_z_spacing);
					union() {
						translate([0,0,h/2-pitot_t/2]) cylinder(r=pitot_r+pitot_t*2,h=h-pitot_t,center=true);
						translate([0,0,h-pitot_t/2-pitot_snap_offset]) difference() {
							cylinder(r1=pitot_r+pitot_t*2,r2=pitot_r+nozzle_r*3,h=pitot_t*1.25,center=true);
							for(r=[0:45:180]) rotate([0,0,r]) cube([pitot_t,tube_or,pitot_t*1.25+extra],center=true);
						}
					}
					translate([0,0,h/2]) cylinder(r=pitot_r+nozzle_r,h=h*1.5+extra,center=true);
				
					
				}
			}
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		for (r=[0:90:365]) rotate([0,0,r]) translate([0,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=tube_or*2+t*4,center=true);
	}
}
module flow_sensor_test() {
	pitot_r=7/2;
	pitot_t=nozzle_r*2*2;
	port_r=5.25/2;
	o_offset=10;
	tube_l=tube_ir*2+o_offset*2;
	translate([0,0,tube_l/2]) difference() {
		if (1) union() {
			cylinder(r=tube_or,h=tube_l,center=true);
			rotate([90,0,0]) hull() for (z=[1,-1]) translate([0,z*o_offset,-tube_or/1.5]) cylinder(r=tube_or/2,h=tube_or/1.15,center=true);
		}
		difference() {
			cylinder(r=tube_ir,h=tube_l+extra,center=true);
			difference() {
				cube([pitot_r*2+pitot_t*2,tube_or*2,tube_l],center=true);
				for (r=[1,0]) mirror([0,0,r]) scale([1,1,1]) translate([0,tube_ir,-tube_ir-o_offset]) rotate([0,90,0]) intersection() {
					rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
				}
			}
		}
		for (r=[90,-90]) rotate([0,r,0]) intersection() {
			cube([pitot_r*2+pitot_t*2,tube_or*2,pitot_r*2+pitot_t*2+extra],center=true);
			scale([1,1,1]) translate([0,tube_ir,-tube_ir]) rotate([0,90,0]) {
				rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
			}
		}
		for (z=[-1,0,1]) translate([0,tube_ir+4,z*o_offset]) rotate([90,0,0]) translate([0,0,0]) cylinder(r=port_r,h=8*2,center=true);
		
	}
}

module bearing_bushing(h=bearing_h,ir=cam_bolt_r,or=bearing_ir) {
	difference() {
		translate([0,0,h/2]) cylinder(r=or+kerf/2,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=ir-kerf/2,h=h+extra,center=true);
	}
}

module bearing_washer(h=bearing_washer_h,ir=cam_bolt_r,or=(bearing_or+bearing_ir)/2) {
	difference() {
		translate([0,0,h/2]) cylinder(r=or,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=ir,h=h+extra,center=true);
	}
}
	
module arm_mount_plate(h=material_t,motor=0) {
	difference() {
		hull() for (x=[-1,1]) translate([x*arm_x_offset,0,h/2]) cylinder(r=bearing_or+bvm_c/4+kerf,h=h,center=true);
		if (! motor) for (y=[1,-1]) translate([0,cam_y_offset*y,h/2]) cylinder(h=h+extra*2,r=cam_l/2+bvm_c*2.5+clearance-kerf,center=true);
		for (x=[-1,1]) translate([x*arm_x_offset,0,0]) translate([0,0,h/2]) cylinder(r=arm_bolt_r-kerf,h=h+extra,center=true);
	}
}
module arm_mount(h=material_t,motor=0) {
	arm_mount_plate(h=h,motor=motor);
}

module base_plate(h=material_t,explode=0,r=bvm_c*5.5,x_pos=x_pos) {
	hull() base_corners(h=h,r=r,x_pos=x_pos);
}

module base_end_model(r=bvm_br,h=material_t,explode=0,slots=1,battery=1) {
	difference() {
		hull() {
			base_plate(h=h);
			translate([0,bvm_y_center+bvm_r*1.15,h/2]) cylinder(r=bvm_r/3,h=h,center=true);
		}
		translate([0,bvm_y_center,h/2]) cylinder(r=r,h=h+extra,$fn=$fn*2,center=true);
		//translate([0,y_pos+housing_h/2,h/2]) cylinder(r=arm_bolt_r,h=h+extra,$fn=$fn*2,center=true);
		translate([0,bvm_y_center+bvm_r*1.15,h/2]) cylinder(r=arm_bolt_r,h=h,center=true);
		base_corners(h=h,extra=extra,x_pos=x_pos-front_recess);
		
		translate([0,bvm_y_center-bvm_r/1.25,0]) {
			for (x=[-1,1]) translate([x*bvm_c*1.5,bvm_c*4,h/2]) cylinder(r=arm_bolt_r/2,h=h+extra,center=true);
			rj45_hole(h=h);
		}
		translate([0,0,-extra/2]) {
			if (slots) base_end_pin_slots(h=h+extra,x_pos=x_pos-front_recess,kerf=kerf);
			if (battery) battery(h=material_t+extra);
		}
	}
}

module base_end_left(r=bvm_tr,h=material_t,explode=0,slots=1,battery=1) {
	base_end_model(r=r,h=h,explode=explode,slots=slots,battery=battery);
}

module base_end_right(r=bvm_br,h=material_t,explode=0,slots=1,battery=1) {
	base_end_model(r=r,h=h,explode=explode,slots=slots,battery=battery);
}

module base_mount_model(h=material_t*2,explode=0) {
	difference() {
		union() {
			translate([0,0,0]) base_plate(h=material_t*2,r=bvm_c*3-material_t/2,x_pos=x_pos-front_recess);
			base_end_pin_slots(h=h,x_pos=x_pos-front_recess);
			translate([0,0,h+explode]) arm_mount(h=material_t*3);
			for (x=[-1,1]) translate([arm_x_offset*x,0,0]) {
				translate([0,0,material_t*5+explode*2]) bearing_washer();
			}
			for (x=[-1]) for (y=[-0.75,0.75]) translate([x*(x_pos+bvm_c*3-front_recess-extra*2),y_pos+y*housing_h/2,h/2]) difference() {
				hull() {
					cube([material_t+extra*4,material_t*5,h],center=true);
					translate([-material_t*5/2,0,0]) cylinder(r=material_t*5/2,h=h,center=true);
				}
				hull() for (a=[-1,1]) translate([-material_t*4/2-a*material_t/2,0,0]) cylinder(r=material_t*3/2,h=h+extra,center=true);
			}
		}
		base_corners(h=h+extra,extra=extra,r=arm_bolt_r,x_pos=x_pos-front_recess);
		//base_wire_holes(h=h+extra,extra=extra);
		base_hall_holes(h=h+extra,extra=extra);
		arm_holes(h=h+extra,extra=extra);
		motor_shaft_hole(r=bearing_or+clearance/4,h=h+extra,extra=extra);
		translate([x_pos,y_pos,h/2]) cube([material_t+extra*2,housing_h+extra*2,h+extra],center=true);
		//for (a=[1]) hull () for (x=[0,1]) for (y=[-1,1]) translate([(-x_pos+x*bvm_c*8)*a,y_pos+y*(housing_h/5.5+bvm_c*2),h/2]) cylinder(r=6/2,h=h+extra,center=true);
		#hull () for (x=[0,1]) for (y=[-1,1]) translate([x_pos-x*bvm_c*7-material_t/2,y_pos+y*(housing_h/2-bvm_c*2.5-x*bvm_c*1.5),h/2]) cylinder(r=6/2+extra,h=h+extra,center=true);
		hull () for (x=[0,1]) for (y=[-1,1]) translate([-x_pos+x*bvm_c*7+material_t/2,y_pos+y*(housing_h/2-bvm_c*8-x*bvm_c*2),h/2]) cylinder(r=6/2+extra,h=h+extra,center=true);
	}
}
module motor_shaft_hole(r=motor_shaft_r*2,h=material_t,extra=extra) {
	translate([0,-cam_y_offset,h/2]) cylinder(r=r,h=h+extra,center=true);
}
module base_mount_left(h=material_t*2,explode=0) {
	mirror([1,0,0]) difference() {
		base_mount_model(h=h,explode=explode);
		translate([(cam_l/2-1.75+(11.5+3)/2),-cam_y_offset+kerf,h/2]) cube([11.5+3,6.35-kerf+clearance/8,h+extra],center=true);
		translate([(cam_l/2-1.75+11.5/2+3),-cam_y_offset+6.35-kerf,h/2]) cube([11.5,6.35-kerf+clearance/8,h+extra],center=true);
		translate([(cam_l/2-1.75+11.5+3+1.67/2-kerf),-cam_y_offset+6.35/2,h/2]) cube([1.67-kerf+clearance/2,6.35*2+6-kerf*2+clearance/8,h+extra],center=true);
		hull() for (a=[1,2]) translate([cam_l/2-1.75+(11.5+3+1.67)*a-kerf,-cam_y_offset+6.35/2,h/2]) cube([1.67-kerf+clearance/8,(6.35*2+2-kerf*2+clearance/8)*a,h+extra],center=true);
	}
}

module nut_support(h=material_t,r1=6.25/2,r2=6) {
	difference() {
		translate([0,0,h/2]) cube([r2*2+kerf*2,r2*2+kerf*2,h],center=true);
		translate([0,0,h/2]) cylinder(r=r1*1.06-kerf,$fn=6,h=h+extra,center=true);
	}
}

module base_mount_right(h=material_t*2) {
	difference() {
		base_mount_model(h=h);
		motor_holes(h=h+extra);
	}
}
module base_bottom(h=material_t) {
	difference() {
		union() {
			hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(x_pos+bvm_c*4),y*(bvm_l/2-h),h/2]) cylinder(r=extra,h=h,center=true);
			for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(x_pos-front_recess),y*(bvm_l/2-h/2),h/2]) cube([material_t*5,material_t,h],center=true);
		}
		for (x=[-1,1]) for (y=[-0.75,-0.75/2,0,0.75/2,0.75]) translate([x*(x_pos+bvm_c*3-front_recess),y*(bvm_l/2),h/2]) cube([material_t,material_t*5,h+extra*4],center=true);
		for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(x_pos-front_recess),y*(material_t*5.5+clearance*2),h/2]) cube([material_t*5,material_t*2,h+extra*4],center=true);
	}
}

module base_front(h=material_t) {
	difference() {
		base_front_model(tabs=1);
		hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(housing_h/2-bvm_c*1-material_t/2),y*(bvm_l/2-material_t-bvm_c*4),h/2]) cylinder(r=cover_bolt_r-clearance/4,h=h+extra,center=true);
	}
}

module base_front_model(h=material_t,r=cover_bolt_r,tabs=0) {
	difference() {
		union() {
			hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(housing_h/2+bvm_c*3-material_t/2),y*(bvm_l/2-h),h/2]) cylinder($fn=1,r=extra,h=h,center=true);
			if (tabs) {
				for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(housing_h/2),y*(bvm_l/2-h/2),h/2]) cube([material_t*5,material_t,h],center=true);
				for (x=[-1,1]) for (y=[-0.75,-0.75/2,0,0.75/2,0.75]) translate([x*(housing_h/2+bvm_c*3),y*(bvm_l/2),h/2]) cube([material_t,material_t*5,h],center=true);
			}
		}
		for (x=[-1,1]) for (y=[-1,1]) translate([x*(housing_h/2+bvm_c-material_t/2),y*(bvm_l/2-material_t-bvm_c*2),h/2]) {
			cylinder(r=r,h=h+extra,center=true);
			//%translate([0,0,h+h/2+extra]) cylinder(r=cover_bolt_r*2,h=h+extra,center=true);
		}
	}
}
		
module base_front_analog(h=material_t) {
	// relative positions for this panel of housing_h and bvm_l dimensions
	// tft is a dirt cheap 320x200 resistive touch screen version here.
	tft_h=50+clearance;
	tft_w=86+clearance;
	tft_d=6;
	tft_y_offset=tft_h/5;
	tft_screen_h=50; // the whole glass poking through
	tft_screen_w=70;
	//tft_screen_h=45; // just the active part
	//tft_screen_w=59;
	//tft_d=8;
	difference() {
		base_front(h=h);
		#translate([tft_y_offset,0,h/2]) cube([tft_screen_h,tft_screen_w,h+extra],center=true);
		for (y=[0:1:3.9]) translate([housing_h/2-bvm_c*3,y*bvm_c*5.5-bvm_c*5.5*1.5,0]) led();
		#for (x=[-1,1]) translate([housing_h/2-bvm_c*3.25,-bvm_l/3.15+bvm_c*3.75*x,0]) button();
		#for (y=[-1,0,1]) translate([housing_h/4*y-housing_h/10,-bvm_l/3.15,0]) rotate([0,0,-90]) pot();
		#for (x=[-1,1]) translate([-housing_h/4-housing_h/10,bvm_l/10*x,0]) rotate([0,0,180]) pot();
	}
}

module base_front_pi(h=material_t,layer=2) {
	// measurements taken from the edge to the respective parts, inline. Messy, but perfect and only needs to live here.
	// touch panel mount is 3 layers at material_t > 2.61mm and material_t < 3mm
	pi_y_outline=97*2;
	pi_x_outline=57*2;
	if (1 && layer == 2) {
		difference() {
			base_front_model(h=h,r=cover_bolt_r+clearance/2);
			translate([(4-6.5)/2,(12-5)/2,h/2]) cube([pi_x_outline-6.5-4,pi_y_outline-12-5,h+extra],center=true);
			//if (1) %hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(55.5-6),y*(96.8-6),h+extra*2]) cylinder(r=6,h=extra,center=true);
		}
	}	
	if (1 && layer == 1) {
		difference() {
			base_front_model(h=h,r=cover_bolt_r+clearance/2);
			translate([(4-6.5)/2,(12-15)/2,h/2]) cube([pi_x_outline-6.5-4,pi_y_outline-12-15,h+extra],center=true);
		}
	}	
	if (1 && layer == 0) {
		difference() {
			base_front_model(h=h,r=cover_bolt_r+clearance/2);
			pi_touchscreen();
		}
	}
}

module base_back_model(h=material_t,tabs=1) {
	base_front_model(h=h,tabs=tabs);
}

module base_back(h=material_t,tabs=0) {
	difference() {
		base_back_model(h=h,tabs=1);
		hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*(housing_h/2-bvm_c*2-material_t/2),y*(bvm_l/2-material_t-bvm_c*3),h/2]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
		#wiper_motor();
		
	}
}	
	
module base_back_wiper(h=material_t) {
	difference() {
		base_back_model(h=h,tabs=0);
		translate([-housing_h/2*0.75,0,0]) #slide_switch();
		translate([housing_h/2*0.75,0,0]) #power_jack();
		#wiper_motor();
		for (x=[-0.75,0.75]) for (y=[-1,1]) translate([x*(housing_h/2),y*(material_t*5.5+clearance*2),h/2]) cube([material_t*5,material_t*2,h+extra*4],center=true);
	}
}
	
module base_top(h=material_t) {
	difference() {
		base_bottom(h=h);
		translate([arm_x_offset,bvm_l/2-arm_w*4,0]) rj45_jack();
		for (x=[-1,1]) translate([arm_x_offset*2*x,0,h/2]) cube([arm_x_offset*2+arm_w*3.5,material_t*3+clearance*2,h+extra],center=true);
	}
}

module base_battery_mount(h=material_t) {
	difference() {
		translate([0,0,0]) base_plate(h=h,r=bvm_c*3-material_t/2,x_pos=x_pos-front_recess);
		translate([0,0,-extra]) battery();
		translate([0,0,-extra/2]) base_corners(x_pos=x_pos-front_recess,h=h+extra);
	}
}

module base_battery_mount_t(h=material_t) {
	difference() {
		intersection() {
			translate([0,housing_h/4,0]) cube([x_pos*2,housing_h/4,h+extra],center=true);
			base_battery_mount(h=h);
		}
	}
}

module base_battery_mount_b(h=material_t) {
	difference() {
		intersection() {
			translate([0,-housing_h/1.35,0]) cube([x_pos*2,housing_h/4,h+extra],center=true);
			base_battery_mount(h=h);
		}
	}
}

module bldc_motor_standoff(h=material_t*2) {
	difference() {
		translate([0,-cam_y_offset-motor_body_y_offset,h/2]) cylinder(r=motor_r,h=h,center=true);
		motor_holes(h=h);
	}
}
			
module motor_mount(h=material_t,r=motor_bolt_r+bvm_c*2){
	for (x=[-1,1]) for (y=[0,1]) translate([x*motor_mount_x/2,-cam_y_offset-motor_mount_offset+motor_mount_y*y,h/2]) cylinder(r=r,h=h,center=true);
}

module motor_holes(h=material_t) {
	if (motor_tri) {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (r=[motor_tri_angle,-motor_tri_angle]) rotate([0,0,r]) translate([0,motor_mount_x,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
			translate([0,-motor_mount_y,h/2]) {
				cylinder(r=motor_bolt_r,h=h*2+extra,center=true);
				translate([0,0,material_t*1.5]) cylinder(r=motor_bolt_r*2,h=h*2+extra,center=true);
			}
		}
	} else {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (x=[-1,1]) for(y=[0,1]) translate([x*motor_mount_x/2,-motor_mount_offset+motor_mount_y*y,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
		}
	}
}

module base_wire_holes(h=material_t) {
        for (x=[-0.85,0.85]) translate([x*(x_pos+bvm_c*2),y_pos-housing_h/5.3,h/2]) hull() for (a=[-1,1]) for (b=[-1,1]) translate([bvm_c*a,bvm_c*b*3,0]) cylinder(r=arm_bolt_r,h=h+extra,center=true);
}

module base_hall_holes(h=material_t) {
	translate([0,-cam_y_offset-cam_bearing_offset-bearing_or/2,h/2]) cylinder(r=5/2,h=h+extra,center=true);
}

module base_corners(h=material_t,r=arm_bolt_r,extra=0,x_pos=x_pos) {
	for (x=[-1,1]) for (y=[-1,1]) translate([x*x_pos,y_pos+y*housing_h/2,h/2]) cylinder(r=r,h=h+extra,center=true);
}

module arm_holes(h=material_t) {
	for (x=[-1,1]) translate([x*arm_x_offset,0,h*8/2]) {
		cylinder(r=arm_bolt_r,h=h*8+extra,center=true);
	}
}

module base_end_pin_slots(h=material_t,x_pos=x_pos,kerf=0) {
	for (x=[-1,1]) for (y=[-0.75,0,0.75]) translate([x*(x_pos+bvm_c*3-extra*2),y_pos+y*housing_h/2,h/2]) cube([material_t-kerf*2+clearance/4,material_t*5-kerf*2+clearance/4,h],center=true);
	for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*x_pos,y_pos+y*(housing_h/2+bvm_c*3-extra*2),h/2]) cube([material_t*5-kerf*2+clearance/4,material_t-kerf*2+clearance/4,h],center=true);
	
	//translate([0,bvm_y_offset,h/2]) cube([bearing_h,bearing_h*1.5,h+extra],center=true);
}

module paddle(paddle_x=paddle_x,paddle_y=paddle_y,laser=0,h=material_t*3) {
	difference() {
		hull() for (y=[-1,1]) for (x=[-1,1]) intersection() {
			translate([x*paddle_x,y*paddle_y,-paddle_y+paddle_t]) sphere(r=paddle_y,center=true);
			translate([x*paddle_x,y*paddle_y,paddle_t]) cylinder(r=paddle_y/2+paddle_t/4,h=paddle_t*2,center=true);
		}
		#translate([0,paddle_y/4,-bvm_c*3.3]) rotate([0,-90,0]) arm_end_mount(h=material_t*3,under=kerf);
	}
}

module arm_end_support(h=material_t*3) {
	if (1) translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2]) rotate([0,0,arm_rot/1.5]) difference() {
		hull() {
			translate([arm_w*1.5,-arm_w*3,0]) cylinder(r=arm_w/2,h=h,center=true);
			translate([arm_w/2.6,0,0]) cylinder(r=arm_w/2,h=h,center=true);
			translate([arm_w*1.5,arm_w*3,0]) cylinder(r=arm_w/2,h=h,center=true);
		}
		translate([arm_w,0,0]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
	}
}

module arm_end_lock(h=material_t) {
	arm_end_mount();
}
module arm_end_hole(h=material_t) {
	translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2])  rotate([0,0,arm_rot/1.5]) translate([arm_w,0,0]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
}

module arm_end_mount(h=material_t,under=0) {
	hull() {
		translate([arm_w*1.5,0,0]) cylinder(r=bvm_c*1.5-under,h=h,center=true);
		translate([arm_w*2.75,-bvm_c,0]) cylinder(r=bvm_c/2-under,h=h,center=true);
		translate([arm_w*2.75,bvm_c,0]) cylinder(r=bvm_c/2-under,h=h,center=true);
	}
}

module arm_model(h=material_t*3,return_spring=0) {
	c1=arm_w*8.35;
	c2=arm_w*4;
	difference() {
		union() {
			// end_mounts
			if (1) translate([arm_x_offset-bvm_r-arm_w*4,bvm_y_center,h/2]) rotate([0,0,arm_rot/1.5]) arm_end_mount(h=h);
			if (1) arm_end_support(h=h);
			// return spring experiment
 			if (0) rotate([0,0,arm_rot/2]) translate([arm_x_offset/2.5,cam_y_offset/1.5,h/2]) {
				cube([material_t*5,material_t,h/2],center=true);	
				cube([material_t*2,material_t*3,h/2],center=true);
			}	
			// end curve
			if (1) translate([arm_x_offset,bvm_y_center,h/2]) intersection() {
				difference() {
					translate([c1/2,-c2/2,0]) scale([1,1.2,1]) cylinder(r=bvm_r+c1,h=h,$fn=$fn*2,center=true);
					translate([c2/2,c2,0]) scale([1,1.3,1]) cylinder(r=bvm_r+c2,h=h+extra*2,$fn=$fn*2,center=true);
				}
				hull() {
					rotate([0,0,-25]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*2,h+extra*4],center=true);
					translate([-bvm_r/2,-bvm_r,0]) rotate([0,0,-138]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*4,h+extra*4],center=true);
				}
			}
			// cam drive and bearing mount
			if (1) hull() {
				translate([arm_x_offset+c1/2,bvm_y_center-c2/2,h/2]) scale([1,1.2,1]) rotate([0,0,-64]) translate([0,-bvm_r-c1,0]) cylinder(r=extra,$fn=1,h=h,center=true);
				translate([arm_x_offset+c2/2,bvm_y_center+c2,h/2]) scale([1,1.3,1]) rotate([0,0,-35]) translate([0,-bvm_r-c2,0]) cylinder(r=extra,$fn=1,h=h,center=true);
				translate([0,0,h/2]) cylinder(r=arm_x_offset-clearance,h=h,center=true);
				translate([arm_x_offset-bearing_or,-cam_y_offset,h/2]) {
					translate([bearing_or*.75/2-clearance,0,0])  rotate([0,0,cam_pre_rot]) cube([bearing_or*1.25,cam_l+arm_w*2,h],center=true);
					translate([0,(cam_l/2-bearing_or)*-1,0]) cylinder(r=bearing_or/2, h=h,center=true);
				}
				translate([arm_x_offset-bvm_c*2,-cam_y_offset-cam_l/2-bvm_c,h/2]) cylinder(r=bvm_c,h=h,center=true);
			}
		}
		rot=0;
		// positioning pin holes
		arm_end_hole(h=h);
		translate([arm_x_offset-bvm_c*2,-cam_y_offset-cam_l/2-bvm_c,h/2]) cylinder(r=cover_bolt_r,h=h+extra,center=true);
		// cam cutout
		if (1) for (i=[0:path_step:180]) {
			if (i<comp_rot) {
				rotate([0,0,i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(h=h+extra,over_h=extra*4,over_r=0,rot=rot);
			} else {
				rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(h=h+extra,over_h=extra*4,over_r=0,rot=rot);
			}
		}
		// bearing cutout
		intersection() {
			translate([0,0,h/2]) cylinder(r=bearing_or+clearance/4,h=h+extra*2,center=true);
			translate([0,0,h/2]) cube([bearing_or*2-clearance/8,bearing_or*2,h+extra*2],center=true);
		}
	}
}

module arm() {
	arm_model();
}
 
module arm_r() {
	mirror([1,0,0]) arm_model();
}
 
module cam(h=material_t,explode=0,d_shaft=d_shaft) {
	union() {
		//translate([0,0,-explode]) cam_end_plate(h=material_t*2,d_shaft=d_shaft);
		translate([0,0,material_t*2]) {
			for (y=[-1,1]) translate([0,cam_bearing_offset*y,0]) {
				bearing_washer();
				translate([0,0,explode+bearing_washer_h]) bearing_bushing(h=h);
			}
			translate([0,0,explode]) cam_center(d_shaft=d_shaft,h=material_t*3/2);
			//cam_center(h=bearing_washer_h,d_shaft=d_shaft);
			
		}
	}
}

module cam_model(over_r=0,over_h=0,rot=0) {
	union() { 
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,-cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,-cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r,h=h+over_h,center=true,$fn=16);
		}
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,cam_bearing_offset,h/2]) cylinder(r=bearing_or+over_r,h=h+over_h,center=true,$fn=16);
		}
		rotate([0,0,cam_pre_rot]) hull() for(i=[-1,1]) translate([0,cam_bearing_offset*i,h/2]) cylinder(r=bearing_or/1.25+over_r,h=h+over_h,center=true,$fn=8);
	}
}

module cam_plate(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		union() {
			for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or-clearance*3,h=h,center=true);
			hull() for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or/1.25,h=h,center=true);
		}
		cam_holes(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
	}
}

module cam_end_plate(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		hull() {
			//cam_plate(h=h,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
			translate([0,0,h/2]) cylinder(r=cam_l/2-bvm_c/2,h=h,center=true);
		}
		cam_holes(h=material_t,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
	}
}

module cam_holes(d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	// bolt/studs
	for(y=[-1,1]) translate([0,cam_bearing_offset*y,cam_h/4]) cylinder(r=cam_bolt_r,h=cam_h,center=true);
	// shaft
	rotate([0,0,(d_shaft-1)*0]) intersection() {
		translate([0,0,cam_h/2]) cylinder(r=motor_shaft_r+clearance/4,h=cam_h+extra,center=true);
		if (d_shaft > 0 )translate([0,motor_shaft_r/2-motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		if (d_shaft > 1) translate([0,-motor_shaft_r/2+motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		if (d_shaft > 2) translate([-motor_shaft_r/2+motor_shaft_r/4.5,0,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		//%cube([8.25,8.25,8.25],center=true);
	}
}
// first shot at an optical encoder.  Sucks for FFF as nozzle_size is used for subtraction, not addition... so... gaps.
module cam_encoder(h=material_t/3,r=cam_l/2+bvm_c*2.45) {
	slot_l=3;
	edge_t=nozzle_r*8+kerf;
	slot_w=1.2-kerf*2;
	translate([0,0,h/2]) color("black") difference() {
		cylinder(r=r,h=h,center=true,$fn=120);
		if (1) for (a=[0:3.6:359]) rotate([0,0,a]) translate([r-slot_l/2-edge_t,6.36,0]) cube([slot_l-kerf*2-clearance,slot_w,h+extra],center=true);
		if (1) for (a=[0:180:359])  rotate([0,0,a]) translate([r-slot_l*1.5-edge_t,0,0]) cube([slot_l-kerf*2-clearance,slot_w,h+extra],center=true);
		cylinder(r=motor_bolt_r-kerf+clearance/4,h=h+extra,center=true);
		for(y=[-1,1]) translate([0,cam_bearing_offset*y,cam_h/4]) cylinder(r=cam_bolt_r*2-kerf+clearance/2,$fn=6,h=cam_h,center=true);
	}
} 	

module cam_center(h=material_t*3,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r) {
	difference() {
		cam_plate(h=h,d_shaft=d_shaft,motor_shaft_r=motor_shaft_r);
		for(i=[-1,1]) translate([0,cam_bearing_offset*i,h/2]) {
			cylinder(r=bearing_or+clearance,h=h+extra,center=true);
			cube([bearing_or*2,bearing_or*1.5,h+extra],center=true);
		}
	}
}

//////////////////////////////////////
////  parts for assemblies/subtraction
module rj45_jack(h=material_t) {
	translate([0,0,h/2]) cube([16-kerf,13.25-kerf,h+extra],center=true);
}

module rj45_hole(h=material_t) {
	translate([0,0,h/2]) cube([16-kerf,16-kerf,h+extra],center=true);
}

module pi_touchscreen(h=material_t,over=0) {
	pi_bolt_y=126/2;
	pi_bolt_x=66/2;
	pi_bolt_offset_y=(32-35)/2;
	pi_bolt_offset_x=(23.5-22.5)/2;
	corner_r=3;
	hull () for (x=[-1,1]) for (y=[-1,1]) translate([(30-24)/2+x*(58.75/2-corner_r/1.44),(-67.5+34.5)/2+y*(91/2-corner_r/1.44),-18/2+material_t]) cylinder($fn=16,r=corner_r+over/2,h=18+extra,center=true);
	for (x=[-1,1]) for (y=[-1,1]) translate([x*pi_bolt_x+pi_bolt_offset_x,y*pi_bolt_y+pi_bolt_offset_y,h/2]) cube([9,13.25-kerf*2,h+extra],center=true);
	hull() for (x=[0,-1]) for (y=[-1,1]) translate([x*50-corner_r/1.44,y*46/2-corner_r/1.44+2,h/2]) cylinder(r=corner_r,h=h+extra,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*60/2-corner_r/1.44+6,y*70/2-corner_r/1.44-(-61.5+73.5)/2,h/2]) cylinder(r=corner_r,h=h+extra,center=true);
}
	
module h_bridge(h=material_t) {
	translate([0,0,21/2]) cube([32,50,21],center=true);
	for (x=[-1,1]) for (y=[-1,1]) translate([x*40/2-1.2,y*40/2,h]) cylinder(r=cover_bolt_r,h=h*2+extra,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*40/2-1.2,y*40/2,-h/2-extra]) cylinder(r=6/2,$fn=4,h=h,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*2/2-21,y*25/2,-20/2-extra]) cylinder(r=6/2,$fn=4,h=20,center=true);
	hull() for (x=[-1,1]) for (y=[-1,1]) translate([x*5/2+18,y*5-10,-10/2-extra]) cube([extra,extra,10],center=true);
}

module wiper_motor() {
	motor_x=35;
	motor_y=33.5;
	translate([0,1,0]) rotate([0,0,0]) h_bridge();
	translate([y_pos+cam_y_offset,-60/2-material_t*7,-x_pos]) {
		rotate([90,0,0]) cylinder(r=79/2,h=60,center=true);
		translate([-motor_x,-motor_y+60/2,x_pos]) {
			cylinder(r=61/2,h=108,center=true);
			translate([0,0,-30]) cylinder(r=30/2,h=188,center=true);
		}
	}
}

module pot(r=7/2,h=material_t) {
	translate([0,0,15.6/2]) cylinder(r=6/2,h=15.6+extra,center=true);
	translate([0,0,7/2]) cylinder(r=7/2,h=7+extra,center=true);
	translate([0,8,h/2]) cube([3,1.5,h+extra],center=true);
	translate([0,0,-9/2-extra]) cylinder(r=17.5/2,h=9,center=true);
	translate([-17.5/2,0,-9/2-extra]) cube([17.5,17.5,9],center=true);
}

module led(r=6/2,h=material_t) {
	translate([0,0,h+2/2]) sphere(r=r-1,center=true);
	translate([0,0,h+1/2+extra]) cylinder(r=r+1,h=1,center=true);
	translate([0,0,h/2]) cylinder(r=r,h=h+extra,center=true);
	translate([0,0,-6/2-extra]) cylinder(r=r+1,h=6,center=true);
}

module button(r=16/2,h=material_t) {
	translate([0,0,h-8/2]) cylinder(r=r,h=8+extra,center=true);
	translate([0,0,h-16/2-extra]) cylinder(r=r-4/2,h=16+extra,center=true);
	translate([0,0,h+8/2+extra]) cylinder(r=r-3/2,h=8,center=true);
	translate([0,0,h+3/2+extra]) cylinder(r=r+3/2,h=3,center=true);
}

module slide_switch(h=material_t) {
	translate([0,0,h/2]) { 
		for (x=[-1,1]) translate([x*9,0,0]) cylinder (r=2/2,h=h+extra,center=true);
		cube([9,4,h+extra*4],center=true);
		translate([0,0,-h/2-1/2-extra]) cube([24,10.5,1],center=true);
		translate([0,0,-h/2-9/2-extra]) cube([16.5,10.5,9],center=true);
		translate([0,0,-h/2-13/2-extra]) cube([9,5.5,13],center=true);
	}
}

module power_jack(r=7/2,h=material_t) {
	translate([0,0,h/2-4]) cylinder(r=r,h=16+extra,center=true);
	translate([0,0,-4/2-extra]) cylinder(r=r*1.5,h=4+extra,center=true);
	translate([0,0,h+2/2+extra]) cylinder(r=r*1.5,h=2+extra,center=true);
}

module bearing(outer=bearing_or*2,inner=bearing_ir*2,width=bearing_h) {
	difference() {
		union() {
			color("grey") difference() {
				cylinder(r=outer/2,h=width,center=true);
				cylinder(r=outer/2.3,h=width+extra,center=true);
			}
			color("grey") difference() {
				cylinder(r=inner/1.4,h=width,center=true);
				cylinder(r=inner/2,h=width+extra,center=true);
			}
			color("orange") cylinder(r=outer/2-extra*4,h=width*.9,center=true);
		}
		color("grey") cylinder(r=inner/2,h=width+extra,center=true);
	}
}

module battery(h=material_t) {
	// battery dimensions
	battery_x=150.5;
	battery_terminal_y=6;
	battery_y=93.5;
	translate([-battery_x/2+50/2+7,y_pos-battery_terminal_y/2+(battery_y/2+h*2/2),h/2]) hull() {
		cube([50,material_t*2+extra*4,h],center=true);
		translate([0,material_t*2+extra,0]) cube([35,material_t*3,h],center=true);
	}
	for (x=[-0.75,0,0.75]) for (y=[-1,1]) translate([x*(x_pos-front_recess),y_pos-battery_terminal_y/2+(battery_y/2+material_t/2-kerf)*y,h/2]) cube([material_t*5-kerf*2+clearance/4,material_t-kerf*2+clearance/4,h],center=true);
	translate([-5/2,y_pos-battery_terminal_y/2,h/2]) cube([battery_x,battery_y,h],center=true);
}

module optical_gate() {
	w=11.67;
	h=11;
	d=6.3;
	slot_d=8.25;
	slot_w=3.3;
	difference() {
		translate([0,h/2,d/2]) cube([w,h,d],center=true);
		translate([0,h-slot_d/2,d/2]) cube([slot_w,slot_d+extra,d+extra],center=true);
		translate([w/2,h,d/2]) rotate([0,0,45]) cube([w/5,h/2,d+extra],center=true);
	}
}
module optical_gates() {
	optical_gate();
	translate([0,0,6.3]) optical_gate();
}
		
	
	

