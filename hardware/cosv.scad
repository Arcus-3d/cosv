//COSV - Cam Open Source Ventilator
// Project home: https://hackaday.io/project/170507
// Project files: https://github.com/Arcus-3d/cosv
// Project author: Daren Schwenke


/* [Global] */

/* [COSV Customization] */
// Circle complexity: Turn down to about 30 for working, up to like 90 for rendering
param_complexity=30; // [1:100]

// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this. Smaller values result in smoother, but more complicated surfaces.  A good value for working is 15. A good value for rendering is 2-5.
param_path_step=15; // [1:15]

// Line width for laser cutting.  Affects hole sizes
param_kerf=0.20; // [0.000:0.005:0.500]

// Motor mount selection
param_motor="bldc"; // [wiper:Ford F150 Wiper Motor,bldc:BLDC Brushless Motor,worm:Worm gear motor,nema23:Nema23 Stepper with 6mm shaft,nema23-635:Nema23 Stepper with 6.35mm shaft]

// Is the motor shaft D-Shaped?
param_d_shaft = "auto"; // [zero:Circular,one:D-Shaped,two:Double-D shaped (wiper motor),auto:D or DD based on motor type]

// Which one would you like to see?
param_part = "arm_l"; // [cam:cam top/bottom - need 2,paddle:paddle for the arms - need 2,base_b:base plate/motor mount - need 1,base_t:top plate/electronics mount - need 1,bldc_motor_standoff:bldc motor standoff - need 1,bag_mount:Thin arms to support the bag ends and keep it from wandering - need 2,arm_l:Arm,supply_cover:Power Supply cover,chest_bar:Chest bar,flow_sensor_for_pcb:Flow sensor body for use with a PCB (pitot style),flow_sensor_venturi_for_pcb:Flow sensor body for use with a PCB (venturi style),flow_sensor_for_pcb_no_pocket:Flow sensor test body,flow_sensor_cover_oled:Flow sensor cover for use with embedded OLED,flow_sensor_cover:Flow sensor cover,flow_sensor_test:Test apparatus for the flow sensor,bearing_bushing:bearing_busing - used within the other FFF parts,bearing_washer:bearing_washer - used within the other FFF parts,laser_callibration_square_10x10mm:Laser calibration square - A 10x10mm square in case units don't go over with the svg export,laser_arm_mount:Laser arm mount - raised area by arm bearings as a layer,laser_bearing_washer:  washer - if laser cutting it,laser_cam:Laser cam top/bottom - need 2,laser_cam_center:Laser cam center - Stronger - but you need to glue it to top/bottom,laser_bearing_bushing:Laser bearing bushing to make up the difference between bolt_r and bearing_ir - need 2,laser_bldc_motor_standoff:Laser bldc motor has an input shaft that sticks out too far,laser_base_t:Laser base - top plate,laser_base_b:Laser base - bottom plate,laser_paddle:Laser paddle for arm ends - need 2,laser_arm:Laser arms - need 2,laser_bag_mount:Laset bag mounting arm - need 2]


/* [Hidden] */


// Laser parts
param_partl="";



// Don't touch $fn, the param_complexity variable is over-ridden in the makefile
$fn=param_complexity;


// Generates the path for the cam.  The cam surface is generated by subtraction of the cam bearing from the surface
// while rotating both the cam and the arms.  This is the angle to rotate between steps when generating this.
// Smaller values result in smoother, but more complicated surfaces.  
// A good value for working is 15. A good value for rendering is 2-5.
path_step=param_path_step; // [1:15]


// Assembly views, a little broken.
//cosv_assembly_view(cam_angle=$t*180,explode=0);
//cam_assembly_view(explode=10);
//flow_sensor_assembly_view(rot=360*$t,explode=0.1);

// The parts.
// Uncomment these to generate them, render, export.
// for the laser files, export as svg.





PART=param_part;

if (PART == "cam") {
	cam(); // cam top/bottom.  Need 2.
} else if (PART == "paddle") {
	paddle(); // paddle for the arms.  Need 2
} else if (PART == "base_b") {
	base_b(); // base plate/motor mount.  Adjust the bolt pattern you need below first.  Need 1.
} else if (PART == "base_t") {
	base_t(); // top plate/electronics mount.  Need 1.
} else if (PART == "bldc_motor_standoff") {
	bldc_motor_standoff(); // bldc motor has a long pilot on it, which requires a standoff. Need 1.
} else if (PART == "bag_mount") {
	bag_mount(); // thin arms to support the bag ends and keep it from wandering. Need 2.
} else if (PART == "arm_l") {
	arm_l();
} else if (PART == "supply_cover") {
	supply_cover();
} else if (PART == "chest_bar") {
	chest_bar();
} else if (PART == "flow_sensor_for_pcb") {
	flow_sensor_for_pcb();
} else if (PART == "flow_sensor_venturi_for_pcb") {
	flow_sensor_venturi_for_pcb();
} else if (PART == "flow_sensor_for_pcb_no_pocket") {
	flow_sensor_for_pcb_no_pocket();
} else if (PART == "flow_sensor_cover_oled") {
	flow_sensor_cover(oled=0);
} else if (PART == "flow_sensor_cover") {
	flow_sensor_cover();
} else if (PART == "flow_sensor_test") {
	flow_sensor_test();
} else if (PART == "bearing_bushing") {
	bearing_bushing(); // parts used within the other FFF parts
} else if (PART == "bearing_washer") {
	bearing_washer(); // parts used within the other FFF parts

// Laser parts.  Arms at least should have arm_w (below) turned up as acrylic isn't as strong as FFF.

} else if (PART == "laser_callibration_square_10x10mm") {
	laser_callibration_square(w=10); // A square, 10x10mm in case units don't go over with the svg export.
} else if (PART == "laser_arm_mount") {
	laser_arm_mount(); // raised area by arm bearings as a layer
} else if (PART == "laser_bearing_washer") {
	laser_bearing_washer(); // washer, if laser cutting it
} else if (PART == "laser_cam") {
	laser_cam(); // cam top/bottom
} else if (PART == "laser_cam_center") {
	laser_cam_center(); //cam center.  Stronger, but you need to glue it to top/bottom
} else if (PART == "laser_bearing_bushing") {
	laser_bearing_bushing(); // bushing to make up the difference between bolt_r and bearing_ir
} else if (PART == "laser_bldc_motor_standoff") {
	laser_bldc_motor_standoff(); // bldc motor has an input shaft that sticks out too far
} else if (PART == "laser_base_t") {
	laser_base_t(); // base, top plate
} else if (PART == "laser_base_b") {
	laser_base_b(); // base, bottom plate
} else if (PART == "laser_paddle") {
	laser_paddle(); // paddle for arm ends
} else if (PART == "laser_arm") {
	laser_arm(); // The arms (when symetrical).  Make sure to reset arm_w to a larger value that for FFF printing.
} else if (PART == "laser_bag_mount") {
	laser_bag_mount();
}

// Abbreviations
// r=radius (and sometimes rotation within modules)
// ir=inner radius
// or=outer radius
// t=thickness
// l=length
// h=height
// x,y,z = dimensions in x,y,z

// Clearance for parts, and extra length to make subtractions clean.
clearance=0.4;
extra=0.02;

// nozzle size for 3D printing.  Generates parts that are exactly a multiple of this width for strength
nozzle_r=0.4/2;

// line width for laser cutting.  Affects hole sizes (param_kerf is CLI overridden by Makefile)
kerf=param_kerf;

// bag dimensions and position
bvm_r=125/2;
bvm_br=70/2;
bvm_tr=45/2;
bvm_l=200;
bvm_c=nozzle_r*2*8; // Thickness for bag parts
bvm_y_offset=15; // Moves the bag location up/down

// not used atm.. was added to the base model.
chest_bar_l=bvm_r*2;

// bearing choice.  Some things don't scale right yet if you change this.
bearing_or=22/2-kerf;
bearing_ir=8/2+kerf;
bearing_h=7;

// a little washer to clearance the bearing
bearing_washer_h=clearance/2;

// assembly bolt size
cam_bolt_r=4/2+clearance/4-kerf;
arm_bolt_r=8/2+clearance/4-kerf;
cover_bolt_r=3/2+clearance/4-kerf;
wire_t=1.25;

// compression rotation angle.  You can generate uneven compression/release profiles with this for a weaker motor, or to have hardware ratio of inhale/exhale and a static motor.
comp_rot=90;

// arm width (If it is laser, do one thing, else FFF, do another
arm_w=(PART == "laser_arm" ? 12*nozzle_r*2 : 12*nozzle_r*2 );

// paddle internal ribs and top thickness
paddle_scale=1.5;
paddle_t=3*nozzle_r*2;
paddle_rib_w=3*nozzle_r*2;

// how far the arm rotates with a full comp_rot
arm_rot=30; 
// how far apart the arm bearings are from centerline
arm_x_offset=18;

// mechanical dimensions for the cam action
cam_bearing_offset=18;
cam_l=cam_bearing_offset*2+bearing_or*2;
cam_thickness=3.2;
cam_h=bearing_h+cam_thickness*2+clearance;
cam_y_offset=bearing_or+cam_l/2+arm_w/2;
cam_pre_rot=-0;
x_pos=arm_x_offset+cam_l/2.5;
y_pos=-cam_y_offset-cam_l/2.5;

supply_cover_x=38;
supply_cover_y=98;
supply_cover_z=20;
supply_cover_t=1.6;

// volume sensing pitot tube dimensions
// outer tube.  This is the dia of the mask, generally
tube_or=22/2;
tube_taper=nozzle_r;
tube_ir=tube_or-nozzle_r*2*6;
// depth of the socket/tube
tube_d=19;

pcb_t=1.6+3.2+clearance; // Board is 1.6, OLED is 5.2mm tall.  Recess in lid is 2mm.
pcb_c_t=2.4;
pcb_b=1.6;
pcb_x=21+clearance;
pcb_y=47+clearance;
pcb_z_offset=4;
pcb_port_z_offset=8;
pcb_port_z_spacing=4;
pcb_port_x_spacing=4;
pcb_bolt_spacing=24;
pcb_cover_t=2.8;
pcb_cable_t=1.5;

// total length
tube_l=tube_d*2+(pcb_y-tube_d)+pcb_z_offset+tube_d*1.25;
vent_l=tube_l/1.35;
vent_h=vent_l/8;
vent_r=8/2;

// inner pitot tube
pitot_r=6/2;
pitot_t=nozzle_r*2*3;
port_r=5.25/2;
pitot_snap_offset=.05;
// oled
oled_x=12+clearance;
oled_y=39+clearance;
oled_pin_h=1;
oled_t=2+oled_pin_h;
oled_glass_x=9;
oled_glass_x_offset=-1;
oled_glass_y=26;

// param_motor is defined at the top of the file (and over-ridden by CLI in Makefile)
MOTOR=param_motor;

// Support makefile passing this in, we have rendered each motor have D or !D shaped for the cams
d_shaft = (param_d_shaft=="zero" ? 0 : 
          (param_d_shaft=="one" ? 1 :
	  (param_d_shaft=="two" ? 2 :
	  (param_d_shaft=="auto" ? (MOTOR=="wiper" ? 2 : (MOTOR=="worm" ? 1 : (MOTOR=="nema23" ? 1 : 0))) : 0))));
motor_tri = (MOTOR=="wiper" ? 1 : 0);
motor_tri_angle = (MOTOR=="wiper" ? 53 : 60);
motor_mount_offset = (MOTOR=="wiper" ? 0
                   : (MOTOR=="worm" ? 9
                   : (MOTOR=="nema23" ? 47.1/2
                   : (MOTOR=="nema23-635" ? 47.1/2
                   : (MOTOR=="bldc" ? 6.25 : 0)))));
motor_mount_x = (MOTOR=="wiper" ? -35
              : (MOTOR=="worm" ? 18
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 15.5 : 0)))));
motor_mount_y = (MOTOR=="wiper" ? -46
              : (MOTOR=="worm" ? 33
              : (MOTOR=="nema23" ? 47.1
              : (MOTOR=="nema23-635" ? 47.1
              : (MOTOR=="bldc" ? 26.75 : 0)))));
motor_r = (MOTOR=="wiper" ? 54
        : (MOTOR=="bldc" ? 37/2 : 0));
motor_bolt_r = (MOTOR=="wiper" ? 6/2+clearance/4-kerf
             : (MOTOR=="worm" ? 3/2+clearance/4-kerf
             : (MOTOR=="nema23" ? 4/2+clearance/4-kerf
             : (MOTOR=="nema23-635" ? 4/2+clearance/4-kerf
             : (MOTOR=="bldc" ? 3/2+clearance/4-kerf : 0))))); 
motor_pilot_r = (MOTOR=="wiper" ? 24/2+clearance-kerf
              : (MOTOR == "worm" ? 6/2+clearance-kerf
              : (MOTOR == "nema23" ? 38.1/2+clearance-kerf
              : (MOTOR == "nema23-635" ? 38.1/2+clearance-kerf : 0))));
motor_shaft_r = (MOTOR=="wiper" ? 6/2+clearance/4-kerf
              : (MOTOR == "worm" ? 6/2-kerf
              : (MOTOR == "nema23" ? 8/2-kerf
              : (MOTOR == "nema23-635" ? 6.35/2-kerf
              : (MOTOR=="bldc" ? 6/2-kerf : 0)))));
motor_shaft_flat_x = (MOTOR=="wiper" ? 8.1/2 : 0);
motor_shaft_flat_y = (MOTOR=="wiper" ? 11/2 : 0);
motor_body_y_offset = (MOTOR=="bldc" ? -7 : 0);


module laser_bag_mount() {
	projection(cut=true) bag_mount(t=arm_w*1.5);
}
module laser_base_t() {
	projection(cut=false) base_t();
}
module laser_bearing_washer() {
	projection(cut=true) bearing_washer();
}
module laser_cam() {
	projection(cut=true) cam_plate();
}
module laser_cam_center() {
	projection(cut=true) cam_center();
}
module laser_arm_mount() {
	projection(cut=true) difference() {
		arm_mount();
		translate([0,0,-cam_thickness*2]) motor_holes();
	}
}
module laser_arm() {
	//arm_model();
	projection(cut=true) arm_model();
}
module laser_paddle() {
	
	projection(cut=true) paddle(laser=1,bearing_h=6.36*2+6.35/2+clearance/2);
}
module laser_bearing_bushing() {
	projection(cut=true) bearing_bushing();
}
module laser_base_b() {
	projection(cut=false) base_b();
}
module laser_callibration_square(w=10) {
	projection(cut=true) cube([w,w,w],center=true);
}
module laser_bldc_motor_standoff() {
	projection(cut=true) bldc_motor_standoff();
}

// now a little screwed up since I split the parts into layers
module cosv_assembly_view(explode=0,cam_angle=0) {
	if (0) translate([0,bvm_r+bearing_or+bvm_c+bvm_y_offset,0]) {
	//if (0) {
		//$fn=32;
		if (cam_angle < comp_rot) {
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-cam_angle/100,1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		} else { 
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,bvm_l/2]) cylinder(r=bvm_tr,h=extra,center=true);
			}
			hull() {
				scale([0.98-(90*2/100-cam_angle/100),1,1.5]) sphere(r=bvm_r,center=true);
				translate([0,0,-bvm_l/2]) cylinder(r=bvm_br,h=extra,center=true);
			}
		}
	}
	if (0) translate([0,0,-cam_thickness*2-explode*4]) base_b();
	if (0) translate([0,0,-cam_thickness-explode*3]) arm_mount();
	if (0) translate([0,-cam_y_offset,0]) rotate([0,0,-cam_angle+cam_pre_rot]) cam_assembly_view(explode=0);
	if (0) translate([0,bvm_y_offset+bearing_or/2,explode*5]) rotate([90,0,90]) translate([0,0,-bearing_h/2]) bag_mount();
	if (0) mirror([0,0,1]) translate([0,bvm_y_offset+bearing_or/2,-explode*5]) rotate([90,0,90]) translate([0,0,-bearing_h/2]) bag_mount();
	if (1) translate([arm_x_offset,0,cam_thickness]) {
		translate([0,0,bearing_h/2]) bearing();
		if (cam_angle < comp_rot) {
			rotate([0,0,cam_angle/(comp_rot/arm_rot)]) {
				arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w,bvm_r+bvm_y_offset+bearing_or+arm_w*5,bearing_h/2]) rotate([0,-90,0]) translate([0,0,-bvm_c*2]) rotate([-arm_rot/2,0,0]) paddle();
			}
		} else {
			rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-cam_angle/(comp_rot/arm_rot)]) {
				arm_r();
				if (1) translate([-arm_x_offset+bvm_r+arm_w,bvm_r+bvm_y_offset+bearing_or+arm_w*5,bearing_h/2]) rotate([0,-90,0]) translate([0,0,-bvm_c*2]) rotate([-arm_rot/2,0,0]) paddle();
			}
		}
	}
	if (1) translate([-arm_x_offset,0,cam_thickness]) {
		translate([0,0,bearing_h/2+clearance]) bearing();
		if (cam_angle < comp_rot) {
			rotate([0,0,-cam_angle/(comp_rot/arm_rot)]) {
				arm_l();
				if (1) translate([arm_x_offset-bvm_r-arm_w/2,bvm_r+bvm_y_offset+bearing_or+arm_w*5,bearing_h/2]) rotate([0,90,0]) translate([0,0,-bvm_c*2]) rotate([-arm_rot/2,0,0]) paddle();
			}
		} else {
			rotate([0,0,-comp_rot/(comp_rot/arm_rot)*2+cam_angle/(comp_rot/arm_rot)]) {
				arm_l();
				if (1) translate([arm_x_offset-bvm_r-arm_w/2,bvm_r+bvm_y_offset+bearing_or+arm_w*5,bearing_h/2]) rotate([0,90,0]) translate([0,0,-bvm_c*2]) rotate([-arm_rot/2,0,0]) paddle();
			}
		}
	}
}


module flow_sensor_assembly_view(explode=0,rot=0) {
	vent_t=tube_or-tube_ir;
	rotate([0,0,rot]) {
		flow_sensor_venturi_for_pcb();
		translate ([0,vent_t+explode,0]) flow_sensor_cover_model(oled=1);
	}
}

module cam_assembly_view(explode=0) {
	translate([0,0,-explode*2-cam_h/2]) cam(explode=explode);
	for(i=[-1,1]) translate([0,cam_bearing_offset*i,0]) bearing();
	translate([0,0,explode*2+cam_h/2]) rotate([0,180,0]) cam(explode=explode);
}
module flow_sensor_cover(oled=0) {
	t=tube_or-tube_ir;
	translate([0,-tube_l/2-tube_d/1.5,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t/2+pcb_b]) rotate([-90,0,0]) flow_sensor_cover_model(oled=oled);
}

module supply_cover() {
	difference() {
		union() {
			translate([0,0,supply_cover_z/2]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z],center=true);
			translate([0,arm_bolt_r+supply_cover_t+clearance/2,supply_cover_z/4]) cube([supply_cover_x+supply_cover_t*2,supply_cover_y+supply_cover_t*2,supply_cover_z/2],center=true);
			hull() {
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r*2,h=supply_cover_x+supply_cover_t*2,center=true);
				translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r/2,extra/2]) cube([supply_cover_x+supply_cover_t*2,extra,extra],center=true);
			}
			
		}
		translate([0,0,supply_cover_z+supply_cover_t]) cube([supply_cover_x,supply_cover_y,supply_cover_z*2],center=true);
		translate([0,supply_cover_y/2+supply_cover_t+arm_bolt_r+clearance/2,supply_cover_z]) rotate([0,90,0]) cylinder(r=arm_bolt_r+clearance/2,h=supply_cover_x+supply_cover_t*2+extra,center=true);
		for (y=[-1,1]) translate([0,supply_cover_y*0.25*y,supply_cover_t/2]) cylinder(r=5.4/2,h=supply_cover_t*4,center=true);
	}
}
module flow_sensor_cover_model(oled=0) {
	t=tube_or-tube_ir;
	vent_t=t;
	if (1) difference() {
		union() {
			hull() for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t+pcb_c_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) {
				rotate([90,0,0]) cylinder(r=pcb_b/2,$fn=$fn/2,h=extra,center=true);
				translate([x*-0.1,pcb_cover_t-pcb_b/2,0]) sphere(r=pcb_b/2,$fn=$fn/2,center=true);
			}
			translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2+wire_t,tube_l-pcb_b*5/2]) difference() {
				translate([0,-pcb_t/2,0]) cube([pcb_x/3-clearance,pcb_c_t+pcb_cover_t,pcb_b*5+extra],center=true);
				translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
				translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2+clearance/2,h=pcb_x/3,center=true);
			}
			// oled rim
			translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset-pcb_b*1.5]) cube([pcb_x-clearance,oled_t/2+extra,oled_y+pcb_b*4],center=true);
			// cover mount
			translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t-pcb_cover_t*0.85,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
				cube([pcb_x-clearance,extra,pcb_b*2.5-clearance/2],center=true);
				rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2-clearance/2,h=pcb_x-clearance,center=true);
			}
		}
		// oled pocket
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b+extra,oled_y+clearance],center=true);
		// oled pins
		translate([0,tube_or+t+pcb_t+pcb_c_t-pcb_b+extra/2+oled_pin_h,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset+oled_y/2-pcb_b]) cube([oled_x+clearance,oled_t+pcb_b/2+extra,oled_t+pcb_b*2],center=true);
		// oled display opening
		if (oled) translate([oled_glass_x_offset,tube_or+t+pcb_t+pcb_c_t+pcb_cover_t,tube_l-(pcb_y+pcb_b*3)/2-pcb_z_offset]) hull() {
			cube([oled_glass_x+t*2,extra,oled_glass_y+t*2],center=true);
			translate([0,-t,0]) cube([oled_glass_x,extra,oled_glass_y],center=true);
		}
		// screw holes
		// cover screw holes
		for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
			rotate([90,0,0]) cylinder(r=cover_bolt_r+clearance/4,h=pcb_t+pcb_c_t+t,center=true);
			translate([0,pcb_cover_t*2,0]) rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
		}
		//translate([0,tube_or+t+pcb_t+pcb_c_t+oled_t/2-pcb_b,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x+clearance,oled_t+pcb_b*2+extra,oled_y+clearance],center=true);
	}
}

// holes still don't scale for depth correctly.
module flow_sensor_for_pcb_no_pocket() {
	t=tube_or-tube_ir;
	intersection() {
		translate([0,0,0]) cube([1000,tube_or*2+t*2+pcb_t*0.91,1000],center=true);
		flow_sensor_for_pcb();
	}
}

module flow_sensor_venturi_for_pcb(sla=1) {
	t=tube_or-tube_ir;
	vent_t=t;
	difference() {
		if (1) union() { // Change to 0 to see all the cutouts
			// body bottom
			for (r=[0,90,180,270]) rotate([0,0,r]) hull() {
				translate([0,tube_or-tube_or/2,tube_d*1.05]) cylinder(r=tube_or/2+tube_taper,h=extra,center=true);
				translate([0,tube_or-tube_or/2,extra]) cylinder(r=tube_or/2,h=extra,center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// body top 
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(tube_or+t-pcb_b/2)*x,tube_or+t+pcb_t/2+pcb_c_t/2+vent_t,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
				translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) sphere(r=port_r/2+nozzle_r*20,center=true);
			}
		}
		difference() {
			if (1) union() {
				// cover screw holes
				for (x=[-1,1]) for (z=[1]) translate([(tube_or-t)*x,tube_or+t*2.5+vent_t+extra/2,tube_l-t*2*z]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=pcb_t+pcb_c_t+t+cover_bolt_r*2,center=true);
					translate([0,pcb_cover_t*2,0]) {
						rotate([90,0,0]) cylinder(r1=cover_bolt_r,r1=cover_bolt_r*4.5,h=cover_bolt_r*4,center=true);
						hull() {
							translate([0,-cover_bolt_r*8.5,0]) sphere(r=cover_bolt_r-clearance/4,center=true);
							translate([0,-cover_bolt_r*6,-cover_bolt_r*6]) sphere(r=cover_bolt_r-clearance/4,center=true);
						}
					}
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2+vent_t,tube_l-pcb_b*3-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t-nozzle_r*4+extra*2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(nozzle_r*4) {
						translate([0,pcb_t*1.15]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,-pcb_t*0.15,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=tube_or*2+t*2+extra,center=true);
				}
				// venturi
				translate([0,0,t/8]) cylinder(r2=tube_ir,r1=tube_ir+t/4,h=t/4+extra,center=true);
				translate([0,0,tube_d/2]) cylinder(r=tube_ir,h=tube_d+extra,center=true);
				translate([0,0,tube_l/2]) {
					translate([0,0,-vent_l/4-vent_h/2-vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
					translate([0,0,-vent_l/8-vent_h/2]) cylinder(r1=tube_ir,r2=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,0]) cylinder(r=vent_r,h=vent_h+extra,center=true);
					translate([0,0,vent_l/8+vent_h/2]) cylinder(r2=tube_ir,r1=vent_r,h=vent_l/4+extra,center=true);
					translate([0,0,vent_l/4+vent_h/2+vent_l/16]) cylinder(r=tube_ir,,h=vent_l/8+extra,center=true);
				}
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					rotate([0,0,45]) hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t+vent_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_cover_t+pcb_t+pcb_c_t,tube_l-pcb_b*5/2]) difference() {
					translate([0,-pcb_t/2,0]) cube([pcb_x/3+clearance/2,pcb_c_t+pcb_cover_t,pcb_b*20+extra],center=true);
					translate([0,-t*2.5,t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
					translate([0,-t*2.5,-t]) rotate([0,90,0]) cylinder(r=t/2,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				translate([0,vent_t,0]) difference() {
					union() {
						if (1) hull() {
							translate([0,tube_or+t,tube_l-pcb_t-pcb_c_t-pcb_t-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t,tube_l-(pcb_y+pcb_b*5.5-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-vent_t-pcb_b*3+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
						}
						if (1) hull() {
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*3-pcb_port_z_offset)/2]) cube([pcb_x,extra,pcb_y-pcb_port_z_offset*2-pcb_b+extra],center=true);
							translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-pcb_y-pcb_z_offset-pcb_b]) cube([pcb_x,extra,extra],center=true);
							translate([0,tube_or+t+pcb_c_t,tube_l-pcb_y+pcb_z_offset]) cube([pcb_x,extra,pcb_port_z_offset*2+pcb_b*2],center=true);
						}
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) {
					rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=t*5,center=true);
					hull() {
						translate([0,-t*5/2,0]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
						translate([0,-t*7.8/2,-t/2]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/4,h=extra,center=true);
					}
				}
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*1.5;
				// ports
				translate([0,vent_t,0]) {
					if (1) for (x=[-1,1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t*4,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,-port_r/8]) sphere(r=port_r,center=true);
					}
					for (x=[-1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
						translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t*4,center=true);
						translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
						translate([0,i,-port_r/8]) sphere(r=port_r,center=true);
					}
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) sphere(r=port_r/2,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4,tube_l/2-vent_l/4-vent_h/2-port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						translate([-pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([0,tube_ir-port_r/2+nozzle_r*4,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) sphere(r=port_r/2,center=true);
					}
					translate([0,tube_ir-t+nozzle_r*4,tube_l/2+vent_l/4+vent_h/2+port_r]) scale([1,1,1.5]) rotate([90,0,0]) cylinder(r=port_r/2,h=port_r/2+nozzle_r*6,center=true);
					hull() {
						translate([pcb_port_x_spacing,i+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8]) sphere(r=port_r,center=true);
						translate([pcb_port_x_spacing,-pcb_c_t/2+o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset-port_r/8+port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
						translate([0,-vent_t,0]) rotate([0,0,-30]) translate([0,vent_r-t+port_r+vent_t,tube_l/2]) scale([1,1,1.75]) rotate([30,-30,0]) sphere(r=port_r/2,$fn=6,center=true);
					}
					translate([0,-vent_t,0]) {
						for (r=[-1,1]) rotate([0,0,90*r]) translate([0,vent_r-t+vent_t+port_r/2-nozzle_r,tube_l/2]) scale([1,1,1.75]) {
							rotate([90,30,0]) cylinder(r=port_r/2,$fn=6,h=port_r+nozzle_r*2,center=true);
							hull() translate([0,port_r/2+nozzle_r,0]) for (r=[0,90]) rotate([0,0,r]) rotate([0,90,0]) cylinder(r=port_r/2,h=extra,$fn=6,center=true);
						}
						intersection() {
							translate([0,tube_or,tube_l/2,]) cube([tube_or*2,tube_or*2,tube_l],center=true);
							rotate_extrude() translate([vent_r-t+vent_t+port_r,tube_l/2]) scale([1,1.75]) rotate([0,0,30]) circle(r=port_r/2,$fn=6,center=true);
						}
					}
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2+vent_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		#if (sla) for (r=[90]) rotate([0,0,r]) translate([tube_ir+t/2,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=t*2,center=true);
	}
}
module flow_sensor_for_pcb() {
	t=tube_or-tube_ir;
	difference() {
		if (1) union() {
			// bottom taper
			for (r=[0,90]) rotate([0,0,r]) hull() {
				translate([0,0,tube_d*1.05]) cube([tube_or*2+tube_taper*2,t,extra],center=true);
				translate([0,0,extra/2]) cube([tube_or*2-clearance/2,t,extra],center=true);
			}
			translate([0,0,tube_d/2]) cylinder(r=tube_or,h=tube_d,center=true);
			// bottom bevel.  SLA printers didn't like this...
			//translate([0,0,t/4]) cylinder(r1=tube_or-t/4,r2=tube_or,h=t/2,center=true);
			// top
			hull() {
				for (z=[0,-pcb_y-pcb_b-pcb_z_offset*2]) translate([0,0,tube_l-t/2+z]) rotate_extrude() translate([tube_or+t-t/2,0]) circle(r=t/2,$fn=$fn/2,center=true);
				//translate([0,0,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset]) cylinder(r=tube_or+t,h=pcb_y+pcb_b*2+pcb_z_offset*2,center=true);
				for (x=[-1,1]) for (z=[-1,1]) translate([(pcb_x+pcb_b)/2*x,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2)/2*z]) rotate([90,0,0]) cylinder(r=pcb_b/2,h=pcb_t+pcb_c_t,$fn=$fn/2,center=true);
// cube([pcb_x+pcb_b*2,pcb_t+pcb_c_t,pcb_y+pcb_b*2+pcb_z_offset*2],center=true);
				translate([0,0,tube_l/2]) cylinder(r=tube_or,h=tube_l-tube_d*2,center=true);
			}
		}
		difference() {
			if (1) union() {
				// screw holes
				for (x=[-1,1]) for (z=[1]) translate([(pcb_x+pcb_b-t*3)/2*x,tube_or+t*2.8+pcb_cover_t+extra/2,tube_l-(pcb_y+pcb_b*2)/2-pcb_z_offset+(pcb_y+pcb_b+pcb_z_offset*2-t*2.5)/2*z]) {
					rotate([90,0,0]) cylinder(r=3/2-clearance,h=pcb_t+pcb_c_t+t,center=true);
					translate([0,pcb_cover_t,0]) rotate([90,0,0]) cylinder(r1=3/2,r1=3,h=3,center=true);
				}
				// led hole/vent
				translate([0,tube_or+t/2+pcb_t/2,tube_l-pcb_b*2-t*2.5-pcb_z_offset]) {
					for (r=[0,180]) rotate([r,0,r]) translate([tube_or+t/2,-pcb_t/2,0]) rotate([0,90,0]) linear_extrude(1) {
						translate([0,pcb_t]) text(size=3,halign="center",valign="center",text="DO NOT");
						translate([0,0]) text(size=3,halign="center",valign="center",text="COVER");
					}
					scale([1,0.5,1.25]) rotate([0,90,0]) cylinder(r=t,h=pcb_x*2,center=true);
				}
				// center cutout
				translate([0,0,tube_l/2]) cylinder(r=tube_ir,h=tube_l+extra*2,center=true);
				// top taper lip
				translate([0,0,tube_l]) cylinder(r1=tube_or,r2=tube_or+t/2,h=t,center=true);
				// top taper cutout
				intersection() {
					hull() {
						translate([0,0,tube_l]) cube([tube_or*2+tube_taper*2,tube_or*2+tube_taper*2,extra],center=true);
						translate([0,0,tube_l-tube_d]) cube([tube_or*2-tube_taper,tube_or*2-tube_taper,extra],center=true);
					}
					translate([0,0,tube_l-tube_d/2]) cylinder(r=tube_or+tube_taper,h=tube_d+extra,center=true);
				}
				// cover mount cutout
				translate([0,tube_or+t+pcb_t+pcb_c_t,tube_l-(pcb_y+pcb_b*2)-pcb_z_offset+pcb_b/2]) hull() {
					cube([pcb_x,extra,pcb_b*2.5],center=true);
					rotate([45,0,0]) translate([0,-pcb_b*2,0]) rotate([0,90,0]) cylinder(r=pcb_b/2,h=pcb_x,center=true);
				}
				// cable_crimp_cutout
				translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) difference() {
					cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset+extra],center=true);
					translate([0,-pcb_t/2-pcb_c_t/2-pcb_cover_t/2,-t/2]) rotate([0,90,0]) cylinder(r=t/3,h=pcb_x/3,center=true);
				}
				// pcb_pocket
				difference() {
					union() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-(pcb_y+pcb_b-pcb_port_z_offset)/2]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_t/2+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([pcb_x,pcb_t+extra,pcb_y+pcb_b+extra],center=true);
					}
					difference() {
						translate([0,tube_or+t+pcb_t/2+pcb_c_t/2,tube_l-pcb_b]) rotate([-45,0,0]) cube([pcb_x,pcb_t+pcb_c_t+extra,pcb_y+pcb_b-pcb_port_z_offset*2+extra],center=true);
						translate([0,tube_or+t+pcb_cover_t/2+pcb_t+pcb_c_t/2,tube_l-pcb_z_offset/2]) cube([pcb_x/3,pcb_t+pcb_c_t+pcb_cover_t,pcb_z_offset*2+extra],center=true);
					}
				}
				// lower screw hole
				for (z=[0]) translate([0,tube_or+pcb_c_t,tube_l-pcb_y-pcb_b+pcb_port_z_offset+z*pcb_port_z_spacing-pcb_z_offset]) rotate([90,0,0]) cylinder(r=cover_bolt_r-clearance/2,h=t*3.75,center=true);
				// pitot pcb ports
				// relative surface height of the top of the ports
				o=tube_or+t+pcb_c_t;
				i=-pcb_c_t-t*3;
				// ports
				for (x=[-1,1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				for (x=[-1]) translate([x*pcb_port_x_spacing,o,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing-pcb_z_offset]) hull() {
					translate([0,-pcb_c_t/2,port_r]) rotate([90,0,0]) cylinder(r=port_r/8,h=pcb_c_t,center=true);
					translate([0,-pcb_c_t/2,-port_r/6]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_c_t,center=true);
					translate([0,i,port_r/3]) rotate([90,0,0]) cylinder(r=port_r/8,h=extra,center=true);
					translate([0,i,-port_r/8]) rotate([90,0,0]) cylinder(r=port_r/2,h=extra,center=true);
				}
				// absolute pressure port
				hull() for (z=[-port_r/4,port_r*2]) translate([pcb_port_x_spacing,tube_or+t+pcb_c_t/2+pcb_t/2,tube_l-pcb_y-pcb_b+pcb_port_z_offset+pcb_port_z_spacing+z-pcb_z_offset]) rotate([90,0,0]) cylinder(r=port_r,h=pcb_t+t,center=true);
			}
			rotate([0,0,25]) { // if you alter the depth of the ports, this needs to change and I'm too lazy to do that math.
				translate([0,0,tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset]) intersection() {
					union() {
						for (r=[1,0]) mirror([0,0,r]) translate([0,tube_ir,tube_ir+pcb_port_z_spacing]) rotate([0,90,0]) difference() {
							union() {
								rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r+pitot_t,center=true);
								translate([tube_ir/2+pcb_port_x_spacing/2,(-tube_or-t)/2,0]) cube([tube_ir+pcb_port_x_spacing,tube_or+t+pitot_r+pitot_t-pcb_b,pitot_t],center=true);
							}
							rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
						}
					}
					translate([0,(tube_ir+t-pitot_r-pitot_t-pcb_b)/2+clearance/4,0]) cube([tube_ir,tube_ir+t+pitot_r+pitot_t-pcb_b,(tube_ir+pcb_port_z_spacing)*2],center=true);
				}
				if (1) difference() {
					h=tube_l-pcb_y-pcb_b+pcb_port_z_offset-pcb_z_offset-nozzle_r-(tube_ir+pcb_port_z_spacing);
					union() {
						translate([0,0,h/2-pitot_t/2]) cylinder(r=pitot_r+pitot_t*2,h=h-pitot_t,center=true);
						translate([0,0,h-pitot_t/2-pitot_snap_offset]) difference() {
							cylinder(r1=pitot_r+pitot_t*2,r2=pitot_r+nozzle_r*3,h=pitot_t*1.25,center=true);
							for(r=[0:45:180]) rotate([0,0,r]) cube([pitot_t,tube_or,pitot_t*1.25+extra],center=true);
						}
					}
					translate([0,0,h/2]) cylinder(r=pitot_r+nozzle_r,h=h*1.5+extra,center=true);
				
					
				}
			}
		}
		if (0) {
			%translate([0,tube_or+t+pcb_t/2+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([pcb_x-pcb_b,pcb_t+extra,pcb_y-pcb_b+extra],center=true);
			#translate([0,tube_or+t+pcb_t/2+pcb_c_t,tube_l-(pcb_y+pcb_b)/2-pcb_z_offset]) cube([oled_x,pcb_t+extra,oled_y],center=true);
		}
		// SLA vent hole.  Without this, sometimes the tube ends up SOLID.
		for (r=[0:90:365]) rotate([0,0,r]) translate([0,0,t]) rotate([0,90,0]) cylinder(r=t/2,h=tube_or*2+t*4,center=true);
	}
}
module flow_sensor_test() {
	pitot_r=7/2;
	pitot_t=nozzle_r*2*2;
	port_r=5.25/2;
	o_offset=10;
	tube_l=tube_ir*2+o_offset*2;
	translate([0,0,tube_l/2]) difference() {
		if (1) union() {
			cylinder(r=tube_or,h=tube_l,center=true);
			rotate([90,0,0]) hull() for (z=[1,-1]) translate([0,z*o_offset,-tube_or/1.5]) cylinder(r=tube_or/2,h=tube_or/1.15,center=true);
		}
		difference() {
			cylinder(r=tube_ir,h=tube_l+extra,center=true);
			difference() {
				cube([pitot_r*2+pitot_t*2,tube_or*2,tube_l],center=true);
				for (r=[1,0]) mirror([0,0,r]) scale([1,1,1]) translate([0,tube_ir,-tube_ir-o_offset]) rotate([0,90,0]) intersection() {
					rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
				}
			}
		}
		for (r=[90,-90]) rotate([0,r,0]) intersection() {
			cube([pitot_r*2+pitot_t*2,tube_or*2,pitot_r*2+pitot_t*2+extra],center=true);
			scale([1,1,1]) translate([0,tube_ir,-tube_ir]) rotate([0,90,0]) {
				rotate_extrude() translate([tube_ir,0]) circle(r=pitot_r,center=true);
			}
		}
		for (z=[-1,0,1]) translate([0,tube_ir+4,z*o_offset]) rotate([90,0,0]) translate([0,0,0]) cylinder(r=port_r,h=8*2,center=true);
		
	}
}

module bearing_bushing(h=bearing_h,r=bearing_ir-clearance/8) {
	difference() {
		translate([0,0,h/2]) cylinder(r=r,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=cam_bolt_r,h=h+extra,center=true);
	}
}

module bearing_washer(h=bearing_washer_h,ir=cam_bolt_r,or=(bearing_or+bearing_ir)/2) {
	difference() {
		translate([0,0,h/2]) cylinder(r=or,h=h,center=true);
		translate([0,0,h/2]) cylinder(r=ir,h=h+extra,center=true);
	}
}
	
module arm_mount_plate(h=cam_thickness) {
	difference() {
		union() {
			hull() {
				for (x=[-1,1]) translate([x*arm_x_offset,0,h/2]) cylinder(r=bearing_or+bvm_c/4,h=h,center=true);
				hull() for (x=[-1,1]) translate([x*(bearing_h),bvm_y_offset+bearing_or-bvm_c,h/2]) cylinder(r=bvm_c,h=h,center=true);
				for (x=[-1,1]) translate([x*(bearing_h),bvm_y_offset+bearing_or-bvm_c,h/2]) cylinder(r=bvm_c,h=h,center=true);
			}
		}
		for (x=[-1,1]) translate([x*arm_x_offset,0,0]) {
			translate([0,0,h/2]) cylinder(r=arm_bolt_r,h=h+extra,center=true);
		}
		translate([0,bvm_y_offset,h/2]) cube([bearing_h,bearing_h*1.5,h+extra],center=true);
	}
}
module arm_mount(h=cam_thickness) {
	arm_mount_plate(h=h);
}

// not right anymore...
module chest_bar(h=cam_thickness*3+bearing_h+bearing_washer_h*2) {
	difference() {
		union() {
			hull() {
				for (x=[-1,1]) for (y=[1]) translate([x*x_pos,y*(y_pos),h/2]) cylinder(r=bearing_or/2,h=h,center=true);
				for (x=[-1,1]) translate([x*x_pos,y_pos,h/2]) cylinder(r=bearing_or/2-clearance/4,h=h,center=true);
				for (x=[-1,1]) translate([x*x_pos,y_pos,h/2]) cylinder(r=arm_bolt_r+bvm_c,h=h,center=true);
				for (x=[-1,1]) translate([x*chest_bar_l/2,y_pos-bvm_c*2,h/2]) cylinder(r=arm_bolt_r+bvm_c*2,h=h,center=true);
			}
			hull() {
				for (x=[-1,1]) translate([x*(x_pos*1.2),y_pos,h/2]) cylinder(r=arm_bolt_r+bvm_c,h=h,center=true);
				for (x=[-1,1]) translate([x*x_pos,y_pos*0.85,h/2]) cylinder(r=arm_bolt_r+bvm_c,h=h,center=true);
			}
		}
		base_holes(h=h);
	}
}
				
module base_plate(h=cam_thickness,explode=0) {
	difference() {
		union() {
			arm_mount(h=h);
			hull() {
				for (x=[-1,1]) for (y=[0,1]) translate([x*x_pos,y*y_pos,h/2]) cylinder(r=bearing_or/2,h=h,center=true);
				//motor_mount(h=h);
			}
			if (1) translate([0,bvm_r+bearing_or/2+bvm_y_offset+arm_w,h/2]) intersection() {
				difference() {
					translate([0,0,0]) cylinder(r=bvm_r+arm_w*3,h=h,$fn=$fn*2,center=true);
					translate([0,0,0]) cylinder(r=bvm_r,h=h+extra,$fn=$fn*2,center=true);
				}
				hull() {
					for(r=[-60,60]) rotate([0,0,r]) translate([0,-bvm_r*8,0]) cube([extra,bvm_r*16,h+extra*3],center=true);
				}
			}
			translate([0,bvm_r+bearing_or/2+bvm_y_offset+arm_w,h/2]) for (r=[-60,60]) rotate([0,0,r]) translate([0,-bvm_r-arm_w*1.5,0]) cylinder(r=arm_w*3/2,h=h,center=true);
			for (x=[-1,1]) hull() {
				translate([0,bvm_r+bearing_or/2+bvm_y_offset+arm_w,h/2]) rotate([0,0,x*60]) translate([0,-bvm_r-arm_w*1.5,0]) cylinder(r=arm_w*3/2,h=h,center=true);

				translate([x*(arm_x_offset)*1.3,0,h/2]) cylinder(r=bearing_or,h=h,center=true);
				translate([x*x_pos,0,h/2]) cylinder(r=bearing_or/2,h=h,center=true);
			}
			chest_bar(h=h);
		}
		base_holes(h=h);
	}
		
}

module base_t(h=cam_thickness,explode=0) {
	difference() {
		union() {
			translate([0,0,0]) base_plate(h=h);
			translate([0,0,h+explode]) arm_mount(h=h*2);
			for (x=[-1,1]) translate([arm_x_offset*x,0,0]) {
				translate([0,0,h*3+explode*2]) bearing_washer();
				translate([0,0,h*3+explode*3+bearing_washer_h]) bearing_bushing(h=bearing_h/2);
			}
		}
		translate([0,-cam_y_offset,h/2]) cylinder(r=motor_shaft_r*1.25+clearance,h=h+extra,center=true);
		base_holes(h=h);
	}
}

module base_b(h=cam_thickness) {
	difference() {
		base_t(h=h);
		motor_holes(h=h);
		base_holes(h=h);
	}
}
module bldc_motor_standoff(h=cam_thickness*2) {
	difference() {
		translate([0,-cam_y_offset-motor_body_y_offset,h/2]) cylinder(r=motor_r,h=h,center=true);
		motor_holes(h=h);
	}
}
			
module motor_mount(h=cam_thickness,r=motor_bolt_r+bvm_c*2){
	for (x=[-1,1]) for (y=[0,1]) translate([x*motor_mount_x/2,-cam_y_offset-motor_mount_offset+motor_mount_y*y,h/2]) cylinder(r=r,h=h,center=true);
}


module motor_holes(h=cam_thickness) {
	if (motor_tri) {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (r=[motor_tri_angle,-motor_tri_angle]) rotate([0,0,r]) translate([0,motor_mount_x,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
			translate([0,-motor_mount_y,h/2]) {
				cylinder(r=motor_bolt_r,h=h*2+extra,center=true);
				translate([0,0,cam_thickness*1.5]) cylinder(r=motor_bolt_r*2,h=h*2+extra,center=true);
			}
		}
	} else {
		translate([0,-cam_y_offset,h/2]) {
			cylinder(r=motor_pilot_r+clearance,h=h+extra,center=true);
			for (x=[-1,1]) for(y=[0,1]) translate([x*motor_mount_x/2,-motor_mount_offset+motor_mount_y*y,0]) {
				cylinder(r=motor_bolt_r,h=h+extra,center=true);
			}
		}
	}
}

module base_holes(h=cam_thickness) {
	for (x=[-1,1]) translate([x*arm_x_offset,0,h*8/2]) {
		cylinder(r=arm_bolt_r,h=h*8+extra,center=true);
	}
	if (0) for (x=[-1,1]) translate([x*x_pos,y_pos,h/2]) {
		cylinder(r=arm_bolt_r,h=h+extra,center=true);
	}
	translate([0,-cam_y_offset-cam_bearing_offset-bearing_or/2,h/2]) cylinder(r=5/2,h=h+extra,center=true);
	for (x=[-1,1]) translate([x*chest_bar_l/2,y_pos-bvm_c*2,h/2]) cylinder(r=arm_bolt_r,h=h+extra,center=true);
	translate([0,bvm_y_offset,h/2]) cube([bearing_h,bearing_h*1.5,h+extra],center=true);
}

module bag_mount(w=arm_w*1.5) {
	union() {
		translate([bvm_r+bearing_h/2,0,bearing_h/2]) scale([1,bvm_l/1.7/bvm_r,1]) {
			union() {
				intersection() {
					difference() {
						translate([0,1.2,0]) cylinder(r=bvm_r+w,h=bearing_h,$fn=$fn*2,center=true);
						cylinder(r=bvm_r,h=bearing_h+extra*2,$fn=$fn*2,center=true);
					}
					intersection() {
						translate([-bvm_r-bvm_tr/1.1,-bvm_r,0]) cube([bvm_r*2,bvm_r*2,bearing_h+extra*3],center=true);
					}
				}
				translate([-bvm_tr/1.5-bearing_h/2,-bvm_r,0]) difference() {
					hull() for (x=[-1,1]) for(y=[-1,1]) translate([x*(bearing_h/4),bearing_h/4*y,0]) cylinder(r=cam_thickness,h=bearing_h,center=true);
					hull() for(y=[-1,1]) translate([0,bearing_h/8*y,0]) cylinder(r=cam_thickness/2,h=bearing_h+extra,center=true);
				}
			}
		}
		hull() {
			translate([-bearing_h/1.9/2-arm_w,3,bearing_h/2]) cube([bearing_h*1.5-clearance,bearing_h*1.5-clearance/2,bearing_h+extra],center=true);
			translate([bearing_h/3,-25,bearing_h/2]) cube([clearance/2,bearing_h*1.5-clearance/2,bearing_h+extra],center=true);
		}
	}
}
				
module paddle(laser=0,bearing_h=bearing_h) {
	difference() {
		union() {
			scale([paddle_scale,paddle_scale,1]) intersection() {
				translate([0,0,-bvm_r/2+bvm_r/6]) sphere(r=bvm_r/2,center=true);
				translate([0,0,bvm_r/2]) cylinder(r=bvm_r/3,h=bvm_r,center=true);
			}
		}
		if (! laser) union() {
			difference() {
				scale([paddle_scale,paddle_scale,1]) intersection() {
					translate([0,0,-bvm_r/2+bvm_r/6-paddle_t-extra]) sphere(r=bvm_r/2,center=true);
					translate([0,0,bvm_r/2-extra]) cylinder(r=bvm_r/3-paddle_t,h=bvm_r,center=true);
				}
				for (x=[0:bvm_r/8:bvm_r]) translate([-bvm_r/2+x,0,0]) cube([paddle_rib_w,bvm_r,bvm_r],center=true);
				for (y=[0:bvm_r/8:bvm_r]) translate([0,-bvm_r/2+y,0]) cube([bvm_r,paddle_rib_w,bvm_r],center=true);
				hull() {
					for (z=[0,bvm_c*1.5]) translate([0,0,z]) rotate([0,90,0]) cylinder(r=bvm_c*1.5+clearance/2+paddle_rib_w,h=bearing_h+clearance/4+paddle_rib_w*2,center=true);
				}
			}
		}
		if (1) hull() {
			for (z=[0,bvm_c*1.5]) translate([0,0,z]) rotate([0,90,0]) cylinder(r=bvm_c*1.5+clearance/2,h=bearing_h+clearance/4,center=true);
		}
	}
}

	
module cam_model(over_r=0,over_h=0,rot=0) {
	union() { 
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,-cam_bearing_offset,bearing_h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=bearing_h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,-cam_bearing_offset,bearing_h/2]) cylinder(r=bearing_or+over_r,h=bearing_h+over_h,center=true,$fn=16);
		}
		hull() {
			rotate([0,0,cam_pre_rot]) translate([0,cam_bearing_offset,bearing_h/2]) cylinder(r=bearing_or+over_r+clearance/4-kerf,h=bearing_h+over_h,center=true,$fn=30);
			//rotate([0,0,cam_pre_rot+rot]) translate([0,cam_bearing_offset,bearing_h/2]) cylinder(r=bearing_or+over_r,h=bearing_h+over_h,center=true,$fn=16);
		}
		rotate([0,0,cam_pre_rot]) hull() for(i=[-1,1]) translate([0,cam_bearing_offset*i,bearing_h/2]) cylinder(r=bearing_or/1.25+over_r,h=bearing_h+over_h,center=true,$fn=8);
	}
}


module bearing(outer=bearing_or*2,inner=bearing_ir*2,width=bearing_h) {
	difference() {
		union() {
			color("grey") difference() {
				cylinder(r=outer/2,h=width,center=true);
				cylinder(r=outer/2.3,h=width+extra,center=true);
			}
			color("grey") difference() {
				cylinder(r=inner/1.4,h=width,center=true);
				cylinder(r=inner/2,h=width+extra,center=true);
			}
			color("orange") cylinder(r=outer/2-extra*4,h=width*.9,center=true);
		}
		color("grey") cylinder(r=inner/2,h=width+extra,center=true);
	}
}

module arm_model() {
	y_pos=-cam_y_offset-cam_l/2;
	c1=arm_w*9.5;
	c2=arm_w*3.25;
	difference() {
		union() {
			// end_mounts
			if (1) translate([arm_x_offset-bvm_r-arm_w*4,bvm_r+bvm_y_offset+bearing_or/2+arm_w*5.5,bearing_h/2]) {
				rotate([0,0,arm_rot/2]) {
					hull() {
						translate([arm_w*1.5,0,0]) cylinder(r=bvm_c*1.5,h=bearing_h,center=true);
						translate([arm_w*2.75,-bvm_c,0]) cylinder(r=bvm_c/2,h=bearing_h,center=true);
						translate([arm_w*2.75,bvm_c,0]) cylinder(r=bvm_c/2,h=bearing_h,center=true);
					}
					hull() {
						translate([arm_w/1.25,0,0]) cylinder(r=arm_w,h=bearing_h,center=true);
						translate([arm_w*1.5,-arm_w*3,0]) cylinder(r=arm_w/2,h=bearing_h,center=true);
						translate([arm_w*1.5,arm_w*2.5,0]) cylinder(r=arm_w/2,h=bearing_h,center=true);
					}
				}
			}
			// end curve
			if (1) translate([arm_x_offset+arm_w,bvm_r+bearing_or/2+bvm_y_offset+arm_w,bearing_h/2]) intersection() {
				difference() {
					translate([arm_w*3.5,-arm_w,0]) cylinder(r=bvm_r+c1,h=bearing_h,$fn=$fn*2,center=true);
					translate([arm_w/2,arm_w,0]) cylinder(r=bvm_r+c2,h=bearing_h+extra*2,$fn=$fn*2,center=true);
				}
				hull() {
					rotate([0,0,-15]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*2,bearing_h+extra*4],center=true);
					translate([-bvm_r/2,-bvm_r,0]) rotate([0,0,-145]) translate([0,-bvm_r*2,0]) cube([extra,bvm_r*4,bearing_h+extra*4],center=true);
				}
			}
			// cam drive and bearing mount
			if (1) hull() {
				translate([arm_x_offset+arm_w,bvm_r+bearing_or+bvm_y_offset,bearing_h/2]) rotate([0,0,-30]) translate([0,-bvm_r-c2,0]) cylinder(r=extra,$fn=1,h=bearing_h,center=true);
				translate([arm_x_offset+arm_w*4.5,bvm_r+bearing_or+bvm_y_offset-arm_w,bearing_h/2]) rotate([0,0,-64]) translate([0,-bvm_r-c1,0]) cylinder(r=extra,$fn=1,h=bearing_h,center=true);
				translate([0,0,bearing_h/2]) cylinder(r=arm_x_offset-clearance,h=bearing_h,center=true);
				translate([arm_x_offset-bearing_or,-cam_y_offset,bearing_h/2]) {
					translate([bearing_or*.75/2-clearance,0,0])  rotate([0,0,cam_pre_rot]) cube([bearing_or*1.25,cam_l+arm_w*2,bearing_h],center=true);
					translate([0,(cam_l/2-bearing_or)*-1,0]) cylinder(r=bearing_or/2, h=bearing_h,center=true);
				}
			}
		}
		rot=0;
		if (0) translate([arm_x_offset+arm_w,bvm_r+bearing_or/2+bvm_y_offset-arm_w,bearing_h/2]) 
			rotate([0,0,-55.9]) translate([0,-bvm_r*4-arm_w*4*2,0]) cylinder(r=bvm_r*3+arm_w*4,h=bearing_h+extra,$fn=$fn*2,center=true);
		// cam cutout
		if (1) for (i=[0:path_step:180]) {
			if (i<comp_rot) {
				rotate([0,0,i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(over_h=extra*4,over_r=0,rot=rot);
			} else {
				rotate([0,0,comp_rot/(comp_rot/arm_rot)*2-i/(comp_rot/arm_rot)]) translate([arm_x_offset,-cam_y_offset,0]) rotate([0,0,-i-rot]) cam_model(over_h=extra*4,over_r=0,rot=rot);
			}
		}
		// bearing cutout
		intersection() {
			translate([0,0,bearing_h/2]) cylinder(r=bearing_or+clearance/4,h=bearing_h+extra*2,center=true);
			translate([0,0,bearing_h/2]) cube([bearing_or*2-clearance/8,bearing_or*2,bearing_h+extra*2],center=true);
		}
	}
}

module arm_l() {
	arm_model();
}
 
module arm_r() {
	mirror([1,0,0]) arm_model();
}
 
module cam(h=cam_thickness,explode=0,d_shaft=d_shaft) {
	union() {
		translate([0,0,-explode]) cam_plate(d_shaft=d_shaft);
		translate([0,0,h-extra]) {
			for (y=[-1,1]) translate([0,cam_bearing_offset*y,0]) {
				translate([0,0,explode+bearing_washer_h]) bearing_bushing(h=bearing_h/2+extra*2);
				bearing_washer();
			}
			translate([0,0,explode+bearing_washer_h]) cam_center(d_shaft=d_shaft);
			cam_center(h=bearing_washer_h,d_shaft=d_shaft);
			
		}
	}
}
module cam_plate(h=cam_thickness,d_shaft=d_shaft) {
	difference() {
		union() {
			for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or-clearance*3,h=h,center=true);
			hull() for(y=[-1,1]) translate([0,cam_bearing_offset*y,h/2]) cylinder(r=bearing_or/1.25-clearance,h=h,center=true);
		}
		cam_holes(h=cam_thickness,d_shaft=d_shaft);
	}
}

module cam_holes(d_shaft=d_shaft) {
	// bolt/studs
	for(y=[-1,1]) translate([0,cam_bearing_offset*y,cam_h/4]) cylinder(r=cam_bolt_r,h=cam_h,center=true);
	// shaft
	rotate([0,0,(d_shaft-1)*0]) intersection() {
		translate([0,0,cam_h/2]) cylinder(r=motor_shaft_r+clearance/4,h=cam_h+extra,center=true);
		if (d_shaft > 0 )translate([0,motor_shaft_r/2-motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		if (d_shaft > 1) translate([0,-motor_shaft_r/2+motor_shaft_r/4.5,cam_h/2]) cube([motor_shaft_r*2,motor_shaft_r*2,cam_h+extra*4],center=true);
		//%cube([8.25,8.25,8.25],center=true);
	}
}

module cam_center(h=bearing_h/2,d_shaft=d_shaft) {
	difference() {
		cam_plate(h=h,d_shaft=d_shaft);
		for(i=[-1,1]) translate([0,cam_bearing_offset*i,h/2]) {
			cylinder(r=bearing_or+clearance,h=h+extra,center=true);
			cube([bearing_or*2,bearing_or*1.5,h+extra],center=true);
		}
	}
}
	

